;	SBC-MON2.Z80  This is a stripped down version of the main MASTER-Z80 (and SBC-MON.Z80 monitor) programs 
;	for use with the S100 bus Z80-FPGA SBC. It will not work with other Z80 CPU Boards without modifications.
; 
;	Assemble and SLR's Z80ASM Assembler (Can also use the Cromemco Assembler)
;	Use:- Z80ASM SBC-MON FH
;
;	NOTE. This board initially utilizes an 16K FPGA ROM module (which behaves the same as a "real" 28C128 EEPROM) 
;	Normally the code resides in four 4K "pages" that can be swapped in one at a time to the Z80 code space
;	at F000H-FFFFH. Currently only 3 pages are used. The code in each page is completely self contained and does
;	not access code in othe pages. All pqages have a common jump table and address switching routine at the start 
;	of each page.  The location of these jumps etc. must be idential in allpages.
;	The pages are named Z80-MONA.Z80, Z80-MONB.Z80 & Z80-MONC.Z80
;
;	To assemble under windows...
;	Load Altair.EXE in Windows CMD box
;	do cpm3
;	I:
;	I:>Submit SBC-MONA.SUB etc.
;
;	There is a submit file for each page.
;
;	SBC-MON2.HEX  is written back to the same windows folder that the PC file "altair.exe" is in.

;	The 2 (or later 3) HEX files need to be combined and loaded into the FPGA as one large .HEX file.
;	Please see here for a discription as to how to do this.
;	http://s100computers.com/My%20System%20Pages/FPGA%20Z80%20SBC/FPGA%20Z80%20SBC.htm
;
;	Recent History...
;
;	V1.0	4/30/2019	Started with the modified MASTER.Z80 V5.1 Monitor. Removed the page switching menu option.
;	V1.01	7/20/2019	Added printer output
;	V2.0	8/21/2019	Added a third page for SD Cards
;	V2.1	7/6/2023	Added speech synthesizer output, activate Z8530 ports
;	V2.2	7/9/2023	Add OTIR long hand in 8080 code format to initilize Z8530s
;	V2.23	7/10/2023	Added clock speed adjustment for Z8530 serial ports
;	V2.31	7/30/2023	Corrected OTIR code in Microcomputer.bsf file
;	V2.31b  7/31/2023       Total code checkout/rebuild
;	V3.0	8/6/2023	Added 4th ROM page with RTC diagnoatic code
;	V3.01	5/22/2024	[WBW] Supported USB Serial on all pages
;	V3.02	6/26/2024	[WBW] Converted IDE CPM Boot to RomWBW load
;	V3.03	7/4/2024	[WBW] Switched RTC SPI to 8-bit interface
;	V3.04	7/5/2024	[WBW] Enhanced SD Card protocol handling
;	V3.05	7/12/2024	[WBW] Converted SD CPM Boot to RomWBW load
;	V3.06	7/24/2024	[WBW] Improved SD Card type detection
;	V3.07	8/2/2024	[WBW] Removed SD Card SPI read/write delay based on FPGA improvements
;	V3.07a	8/22/2024	[WBW] Improved loop delay timing in SD Card Activation 
;
FALSE		EQU	0
TRUE		EQU	NOT FALSE
;
;--------------------------------------------------------
;        Basic MONITOR Routines		Page #0/Power-up
;        IDE Routines			Page #1
;        SD Card Routines		Page #2
;        RTC Routines			Page #3
;--------------------------------------------------------
;
;
MONITOR_BASE	EQU	0F000H		;Start of monitor after a reset								
RAM_BASE	EQU	0C000H		;Default location of RAM buffer area for IDE/CF card diagnostic routines
					;Can be changed with "D" IDE menu command

SCROLL		EQU	01H					
BELL		EQU	07H
SPACE		EQU	20H
TAB		EQU	09H		;TAB ACROSS (8 SPACES FOR SD-BOARD)
CR		EQU	0DH
LF		EQU	0AH
FF		EQU	0CH
QUIT		EQU	11H		;Turns off any screen enhancements (flashing, underline etc).
NO_ENH		EQU 	17H		;Turns off whatever is on
FAST		EQU	10H		;High speed scroll
ESC		EQU	1BH
DELETE		EQU	7FH
BACKS		EQU	08H
CLEAR		EQU	1AH		;TO CLEAR SCREEN
RST7		EQU	38H		;RST 7 (LOCATION FOR TRAP)
NN		EQU	0H		;[I] INITIAL VALUE
SOH		EQU	1		;For XModem etc.
EOT		EQU	4
ACK		EQU	6
NAK		EQU	15H
;

; Note on the mapping below: The DIP switches on the physical board connect to GND with pull up resistors 
; OPEN/OFF switches are '1's and CLOSED/ON DIP switches are '0's
;
; BIT MAP OF IOBYTE BASE_PORT + 6H:- X X X X  X X X X  (if xxxxx111= 111 = CONSOLE IN/OUT DATA for all Console IO board
;			             | | | |  | | | |..............  110 = will use onboard USB chip for ALL Console I/O
;			             | | | |  | | |................  x0x = will force/override onboard FPGA code, to PS2 keyboard input 
;			             | | | |  | |..................  0xx = will force/override, VGA for Console output
;			             | | | |  |....................  0 = Send Console Data to Printer as well as console.
;			             | | | |.......................  Unused			
;			             | | |.........................  Unused							 
;			             | |...........................  Unused
;			     	     |.............................  0 Low Speed Clock for CPU (2mHz).
;
;
;

BASE_PORT	EQU	30H		;Note by using 30H we can use software already on CF-CARDS for the Z80 SBC board
USB_STATUS_PORT	EQU	BASE_PORT+4H	;Status port for USB console input port
USB_DATA_PORT	EQU	BASE_PORT+5H	;Data port for USB console port
IOBYTE		EQU	BASE_PORT+6H	;See above

PS2_STATUS_PORT	EQU	02H		;PS2 Keyboard input port
PS2_DATA_PORT	EQU	03H

DIAG_LEDS	EQU	06H		;LED BAR of FPGA Board (and LED Bar on V3 SMB if present)
SW_TMAX		EQU	0EEH		;OUTPUT BIT 0 HIGH FROM THIS PORT LOWERS DMA0* on V3 SMB (if present)
					;OUTPUT BIT 1 HIGH FROM THIS PORT LOWERS DMA1* on V3 SMB (if present)
					;OUTPUT BIT 2 HIGH FROM THIS PORT LOWERS DMA2* on V3 SMB (if present)
					;OUTPUT BIT 3 HIGH FROM THIS PORT LOWERS DMA3* on V3 SMB (if present) 
SW_TMA0	EQU	0EDH			;INPUT FROM THIS PORT LOWERS DMA0* (SWITCHES IN THE 8088,8086,80286 or 80386 boards)


					;Note these DMA lines are only used in master/slave changes. Not normally used here.

RAM_BANK	EQU	36H		;Port to switch Low/High 32K RAM Page
ROM_PAGE	EQU	07H		;Port to inactivate the the onboard FPGA ROM or switch in/out one of the four 4k pages.

MPGSEL_0	EQU	78H		; Z2 MEM MGR BANK 0 PAGE SELECT REG (0K-16K)
MPGSEL_1	EQU	79H		; Z2 MEM MGR BANK 1 PAGE SELECT REG (16K-32K)
MPGSEL_2	EQU	7AH		; Z2 MEM MGR BANK 2 PAGE SELECT REG (32K-48K)
MPGSEL_3	EQU	7BH		; Z2 MEM MGR BANK 3 PAGE SELECT REG (48K-64K)
MPGENA		EQU	7CH		; Z2 MEM MGR PAGING ENABLE REGISTER (BIT 0, WRITE ONLY)

PRINTER_STROBE	EQU	0C6H		;PRINTER DATA STROBE PORT OUT
PRINTER_STATUS	EQU	0C7H		;PRINTER STATUS PORT IN
PRINTER_OUT	EQU	0C7H		;PRINTER DATA PORT OUT

SPEED_PORT	EQU	07H		;Bit 7 HIGH forces CPU to SLOW State
	
VGA_CURSOR_X	EQU	0C0H		;Port to set VGA video cursor
VGA_CURSOR_Y	EQU	0C1H
VGA_COLOR	EQU	0C2H		;Port to set text color
VGA_BASE	EQU	0E000H		;The VGA text will reside from E000H to EC7FH
VGA_BASE_END	EQU	0EC7FH		;Last character at bottom RHS
TOTAL_VGA_LINES	EQU	38		;26H
RAM_POINTER	EQU	VGA_BASE+0FFEH	;Will store VGA RAM Pointer at very top or its RAM.
LOCAL_X		EQU	VGA_BASE+0FFDH
LOCAL_Y		EQU	VGA_BASE+0FFCH

MODEM_SEND_MASK	EQU	4
SEND_READY	EQU	4		;VALUE WHEN READY
MODEM_RECV_MASK	EQU	1
RECV_READY	EQU	1		;BIT ON WHEN READY
MODEM_ERR_LIMIT	EQU	8		;Max number of Modem serial port re-reads aborting
MODEM_RTS_DELAY	EQU	1		;Time to check Modem RTS line (See XMODEM_LOAD & P_XMODEM_LOAD). Not critical.

RECVD_SECT_NO	EQU	0H		;IX Offset for XModem Recieved Sector Number
SECTNO		EQU	1H		;IX Offset for XModem CURRENT SECTOR NUMBER 
ERRCT		EQU	2H		;IX Offset for XModem ERROR COUNT
					
;****************************************************************************************************************
;
;		 EQUATES FOR OTHER POSSIBLE BOARDS IN THE S100 BUS SYSTEM
;               (Note. If the board is not present the code will ignore the hardware)
;
;****************************************************************************************************************
    					;FOR S100 BUS 8259A (If Present)
MASTER_PIC_PORT	EQU	20h		;Hardware port the 8259A (two ports 20H & 21H)
MasterICW1	equ	00010111B	;EDGE triggered, 4 bytes, single Master,ICW4 needed
MasterICW2	equ	8H		;Base address for 8259A Int Table (IBM-PC uses 8X4 = 20H)
MasterICW3	equ	0H		;No slave
MasterICW4	equ	00000011B	;No special mode, non buffer, Auto EOI, 8086.  ;<<<<,

;-------------- S100Computers PROPELLER CONSOLE_IO (OR SD SYSTEMS VIDIO BOARD) FOR CONSOLE INPUT & OUTPUT

S100_CONSOL_STATUS	EQU	0H	;Note will utilize this board if IOBYTE bits 0 & 1 are ZERO (or bit 5 is 1).	
S100_CONSOL_IN		EQU	1H
S100_CONSOL_OUT		EQU	1H

;-------------- S100Computers I/O BOARD PORT ASSIGNMENTS  (A0-AC)

BCTL		EQU	0A0H		;CHANNEL B CONTROL  (SPEECH PORT) ;<--- Adjust as necessary, 
BDTA		EQU	0A2H		;CHANNEL B DATA
ACTL		EQU	0A1H		;CHANNEL A CONTROL (MODEM_CTL_PORT)		
ADTA		EQU	0A3H		;CHANNEL A DATA (MODEM_DATA_PORT)

MODEM_CTL_PORT	EQU	0A1H	 	;A1H (Note modem I/O will be on CHANNEL A. Speaker on CHANNEL B
MODEM_DATA_PORT	EQU	0A3H		;A3H 

;-------------- S100Computers IDE HARD DISK CONTROLLER COMMANDS ETC. (for Z80_MONB.Z80) -------------------------------------

IDEPORTA	EQU	030H		;Lower 8 bits of IDE interface (8255)
IDEPORTB	EQU	031H		;Upper 8 bits of IDE interface
IDEPORTC	EQU	032H		;Control lines for IDE interface
IDEPORTCTRL	EQU	033H		;8255 configuration port

READCFG8255	EQU	10010010b	;Set 8255 IDEportC to output, IDEportA/B input
WRITECFG8255	EQU	10000000b	;Set all three 8255 ports to output mode

;IDE control lines for use with IDEportC.  

IDEA0LINE	EQU	01H		;direct from 8255 to IDE interface
IDEA1LINE	EQU	02H		;direct from 8255 to IDE interface
IDEA2LINE	EQU	04H		;direct from 8255 to IDE interface
IDECS0LINE	EQU	08H		;inverter between 8255 and IDE interface
IDECS1LINE	EQU	10H		;inverter between 8255 and IDE interface
IDEWRLINE	EQU	20H		;inverter between 8255 and IDE interface
IDERDLINE	EQU	40H		;inverter between 8255 and IDE interface
IDERSTLINE	EQU	80H		;inverter between 8255 and IDE interface

;Symbolic constants for the IDE Drive registers, which makes the
;code more readable than always specifying the address bits

REGDATA		EQU	IDEcs0line					;(08H)
REGERR		EQU	IDEcs0line + IDEa0line				;(09H)
REGSECCNT	EQU	IDEcs0line + IDEa1line				;(0AH)
REGSECTOR	EQU	IDEcs0line + IDEa1line + IDEa0line		;(0BH)
REGCYLINDERLSB	EQU	IDEcs0line + IDEa2line				;(0CH)
REGCYLINDERMSB	EQU	IDEcs0line + IDEa2line + IDEa0line		;(0DH)
REGSHD	EQU	IDEcs0line + IDEa2line + IDEa1line			;(0EH)
REGCOMMAND	EQU	IDEcs0line + IDEa2line + IDEa1line + IDEa0line	;(0FH)
REGSTATUS	EQU	IDEcs0line + IDEa2line + IDEa1line + IDEa0line
REGCONTROL	EQU	IDEcs1line + IDEa2line + IDEa1line
REGASTATUS	EQU	IDEcs1line + IDEa2line + IDEa1line + IDEa0line

;IDE Command Constants.  These should never change.

COMMANDrecal	EQU	10H
COMMANDread	EQU	20H
COMMANDwrite	EQU	30H
COMMANDinit	EQU	91H
COMMANDid	EQU	0ECH
COMMANDspindown	EQU	0E0H
COMMANDspinup	EQU	0E1H


; IDE Status Register:
;  bit 7: Busy	1=busy, 0=not busy
;  bit 6: Ready 1=ready for command, 0=not ready yet
;  bit 5: DF	1=fault occured insIDE drive
;  bit 4: DSC	1=seek complete
;  bit 3: DRQ	1=data request ready, 0=not ready to xfer yet
;  bit 2: CORR	1=correctable error occured
;  bit 1: IDX	vendor specific
;  bit 0: ERR	1=error occured

SEC$SIZE	EQU	512		;Assume sector size as 512. (Not tested for other sizes)
MAXSEC		EQU	3DH		;Sectors per track for CF my Memory drive, Kingston CF 8G. (For CPM format, 0-3CH)
					;This translates to LBA format of 1 to 3D sectors, for a total of 61 sectors/track.
					;This CF card actully has 3F sectors/track. Will use 3D for my CPM3 system because
					;my Seagate drive has 3D sectors/track. Don't want different CPM3.SYS files around
					;so this program as is will also work with a Seagate 6531 IDE drive

MAXTRK		EQU	0FFH		;CPM3 allows up to 8MG so 0-256 "tracks"
BUFFER$ORG	EQU	3000H		;<----- Will place all sector data here

CPM$BOOT$COUNT	EQU	12		;Allow up to 12 CPM sectors for CPMLDR
CPMLDR$ADDRESS	EQU	100H		;Load the CPMLDR at 100H in RAM 

RAM_BANK	EQU	36H		;Port to switch Low/High 32K RAM Page
ROM_PAGE	EQU	07H		;Set ROM page of FPGA ROM

SD_CARD_BASE	EQU	06CH

SD_DATA_OUT	EQU	SD_CARD_BASE		; (6CH) Data TO port to SD CONTRROLLER
SD_DATA_IN	EQU	SD_CARD_BASE		; (6CH) Data TO port to SD CONTRROLLER
SD_SPEED_PORT	EQU	SD_CARD_BASE+1		; (6DH) HIGH TO READ/WRITE SECTORS WITH HIGH SPEED SPI CLOCK
SD_CS_PORT	EQU	SD_CARD_BASE+2		; (6EH) SD Select Port
SD_STATUS	EQU	SD_CARD_BASE+2		; (6EH) SD Status Port
SD_RW		EQU	SD_CARD_BASE+3		; (6FH) Port to pulse SPI Read/Write

HIGH_SPEED	EQU	01H;		; Select SPI 10MHz CLK
LOW_SPEED	EQU	00H		; Select SPI 4KHz CLK (Default on startup)
SD_CS_A		EQU	0FEH		; CS* select bit for SD Card drive A
SD_CS_B		EQU	0FDH		; CS* select bit for SD Card drive B 
SD_BUSY		EQU	01H;
SD_CS_READ_A	EQU	80H;		; Bit to test if Drive A CS* pin is low (not currently used)
SD_CS_READ_B	EQU	40H;		; Bit to test if Drive B CS* pin is low (not currently used)

MONITOR		EQU	0F000H		; Location of Z80 ROM monitor when done.

DEBUG EQU FALSE				; For a display of error codes returned from CF-Card drive


; -------------------------- RAM usage for IDE & RTC Routines (in Z80_MONB.Z80,Z80_MONC.Z80 & Z80_MOND.Z80)  ---------------

IDBUFFER	EQU	RAM_BASE+ 1000H		;512 Bytes @ (C000H+1000H = D000H) for CF-Card paramaters 
buffer		EQU	RAM_BASE		;Default DMA buffer at C000H

@DMA		EQU	RAM_BASE + 1F00H	;Remember Stack is at ~DFF0H
@DRIVE$SEC	EQU	RAM_BASE + 1F02H
@DRIVE$TRK	EQU	RAM_BASE + 1F04H
@SEC		EQU	RAM_BASE + 1F06H
@TRK		EQU	RAM_BASE + 1F08H
@STARTLINEHEX	EQU	RAM_BASE + 1F10H
@STARTLINEASCII	EQU	RAM_BASE + 1F12H
@BYTE$COUNT	EQU	RAM_BASE + 1F14H
@SECTOR$COUNT	EQU	RAM_BASE + 1F16H
@DELAYSTORE	EQU	RAM_BASE + 1F18H

@YEAR:		EQU	RAM_BASE + 1F1AH
@MONTH:		EQU	RAM_BASE + 1F1CH
@DATE:		EQU	RAM_BASE + 1F1EH
@HOURS:		EQU	RAM_BASE + 1F20H
@MINUTES:	EQU	RAM_BASE + 1F22H
@SECONDS:	EQU	RAM_BASE + 1F24H

@CARD_TYPE	EQU	RAM_BASE + 1F26H	;For SD cards
@CURRENT_DRIVE	EQU	RAM_BASE + 1F28H
@SEC_ADDRESS	EQU	RAM_BASE + 1F2AH


;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;-------------------------------- START OF ACTUAL MONITOR @ FOOOH --------------------------------------------------
;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////


ORG		MONITOR_BASE		;<--------<<<<<< LOCATION OF START OF MONITOR, F000H >>>>>>>>>>>>>>>>>>>>>>

;PROGRAM CODE BEGINS HERE

ZAPPLE:	JP	COLD			;INITILIZATION ON RESET

;----------------->>> THIS CODE MUST BE AT THE SAME LOCATION AS FOR THE LOW PAGE ROM CODE <<<---------
;
;THIS CODE MUST BE AT THE SAME LOCATION FOR ALL ROM PAGES (SBC-MONA.Z80,SBC-MONB.Z80,SBC-MONC.Z80,SBC-MOND.Z80)

ACTIVATE_1_HIGH_PAGE:			; SWITCH TO HIGH PAGE #1 of ROM
	LD	A,01H			; 01H for ROM A12 HIGH Page
	OUT	(ROM_PAGE),A	
	JP	START			; Will arrive here only IF no address line switch. 

ACTIVATE_2_HIGH_PAGE:			; SWITCH TO HIGH PAGE #2 of ROM
	LD	A,04H			; 04H for ROM A13 HIGH Page
	OUT	(ROM_PAGE),A	
	JP	START			; Will arrive here only IF no address line switch. 

ACTIVATE_3_HIGH_PAGE:			; SWITCH TO HIGH PAGE #3 of ROM
	LD	A,05H			; 05H for ROM A12 & A13 HIGH Page
	OUT	(ROM_PAGE),A	
	JP	START			; Will arrive here only IF no address line switch. 

ACTIVATE_LOW_PAGE:			; RETURN BACK TO LOW PAGE OF ROM
	NOP
	NOP
	NOP
	NOP
	JP	START			; <---- Switching back to LOW page will arrive here


;----------------------->>> END OF COMMON CODE LOACTIONS <<<----------------------------------
;
;	NOTE TABLE MUST BE WITHIN 0-FFH BOUNDRY (CHECK YOUR LISTING)
;
;COMMAND BRANCH TABLE

TBL:	DW  FLUSH			; "@"  SEND FF to LaserJet printer
	DW  MEMMAP			; "A"  DISPLAY A MAP OF MEMORY
	DW  BEGIN			; "B"  
	DW  BEGIN			; "C"  
	DW  DISP			; "D"  DISPLAY MEMORY (IN HEX & ASCII)
	DW  ECHO			; "E"  ECHO CHAR IN TO CHAR OUT
	DW  FILL			; "F"  FILL MEMORY WITH A CONSTANT
	DW  GOTO			; "G"  GO TO [ADDRESS]
	DW  BEGIN			; "H"  
	DW  IDE_MENU			; "I"  GOTO IDE MENU
	DW  RAMTEST			; "J"  NON-DESTRUCTIVE MEMORY TEST 
	DW  KCMD			; "K"  DISPLAY THE LIST OF SBC-Z80 COMMANDS
	DW  RTC_MENU			; "L"  Do RTC Diagnostics
	DW  MOVE			; "M"  MOVE BLOCK OF MEMORY (START,FINISH,DESTINATION)
	DW  CPM_BOOT_SD			; "N"  Boot up CPM on SD card Drive
	DW  NOT_DONE			; "O"  Boot up 8086 (if present)
	DW  CPM_BOOT_IDE		; "P"  Boot up CPM on IDE Drive
	DW  QUERY			; "Q"  QUERY PORT (IN OR OUT)
	DW  INPORTS			; "R"  Read ALL Input Ports
	DW  SUBS			; "S"  SUBSTITUTE &/OR EXAMINE MEMORY
	DW  TYPE			; "T"  TYPE ASCII PRESENT IN MEMORY 
	DW  SD_MENU			; "U"  GOTO SD CARD MENU
	DW  VERIFY			; "V"  COMPARE MEMORY
	DW  INTS_OK			; "W"  Allow Interrupts
	DW  BOOT_XMODEM			; "X"  Download a file over USB port to RAM
	DW  SWAP_RAM			; "Y"  Switch lower 32K RAM page
	DW  SIZE			; "Z"  FIND HIGHEST R/W RAM
;
IDE_MENU:	
	LD	D,1			; [B],Jumps to HIGH PAGE #1 code with 1 in [D] to indicate IDE MENU menu option
	JP	ACTIVATE_1_HIGH_PAGE
CPM_BOOT_IDE:
	LD	D,2			; [B],Jumps to HIGH PAGE #1 code with 2 in [D] to indicate CPM_BOOT menu option
	JP	ACTIVATE_1_HIGH_PAGE

SD_MENU:	
	LD	D,3			; [C], Jumps to HIGH PAGE #2 code with 3 in [D] to indicate SD CARD MENU menu option
	JP	ACTIVATE_2_HIGH_PAGE
CPM_BOOT_SD:	
	LD	D,4			; [C],Jumps to HIGH PAGE #2 code with 4 in [D] to indicate SD CARD CPM BOOT option
	JP	ACTIVATE_2_HIGH_PAGE

RTC_MENU:	
	LD	D,5			; [D], Jumps to HIGH PAGE #3 code with 5 in [D] to indicate RTC MENU menu option
	JP	ACTIVATE_3_HIGH_PAGE

;-------------------------------------------------------------------------------------------------------------

COLD:	LD	A,'#'			;For quick hardware diagnostic test
	OUT	(S100_CONSOL_OUT),A	;Force a "#" on the CRT if ROM access is active
	
BEGIN:					;Can use the next 3 lines initially to debug hardware
	DI				;Enable interrupts
	IM1				;Set to Z80 INT Mode 1 (SO ALL interrupts to 38H in RAM)
	
	; At the moment, MMU must be enabled prior to
	; making changes to the MMU bank registers.  This is not
	; ideal, so need to correct the FPGA programming someday.
	LD	A,1
	OUT	(MPGENA),A		; enable MMU bank management

	; RomWBW wants the default MMU mapping such that the top
	; 32K (common) is mapped to the top 32K of physical RAM and
	; the bottom 32K is mapped to the bottom 32K of physical RAM.
	; We do that here.  Note physical RAM is assumed to be 512K.
	; 512K / 16K = 32 banks total
	XOR	A			; First 16K of physical RAM
	OUT	(MPGSEL_0),A		; ... goes to first 16K CPU
	INC	A			; Second 16 of physical RAM
	OUT	(MPGSEL_1),A		; ... goes to second 16K CPU
	LD	A,32 - 1		; Last bank of physical RAM
	OUT	(MPGSEL_3),A		; ... goes to last 16K CPU
	DEC	A			; Next to last bank of physical RAM
	OUT	(MPGSEL_2),A		; ... goes to next to last 16K CPU

	XOR	A			
	OUT	(RAM_BANK),A		;Start in default LOW RAM Page
	OUT	(ROM_PAGE),A		;Start in default ROM F000-FFFFH Z80_MONA
	
	OUT	(SW_TMAX),A		;Make sure TMA0*,TMA1*,TMA2* & TMA3* S100 lines are high on V2 SMB (if present)

					;Turn all LED's OFF as a diagnostic on SMB V2 and this board
BEGIN1:	LD	A,00000000B		;FLAG PROGRESS VISUALLY FOR DIAGNOSTIC 
	OUT	(DIAG_LEDS),A		;LED's will go off one at a time

SETUP_STACK:
	LD	SP,AHEAD-4		;SETUP A FAKE STACK
	JP	MEMSZ1			;RETURNS WITH TOP OF RAM IN [HL]
	DW	AHEAD			;A Return opcode will pick up this address
AHEAD:
	LD	L,0F0H			;We will make space for extra RAM parameters (Like RAM_POINTER)
	LD	SP,HL			;[HL] CONTAINS TOP OF RAM - WORK AREA
	PUSH	HL
	POP	IX			;Store stack pointer for below in [IX]


	IN	A,(IOBYTE)		;Get IOBYTE 
	AND	A,00000111B
	OR	A,10000000B		;FLAG PROGRESS VISUALLY FOR DIAGNOSTIC ((Bit 7 LED on)
	OUT	(DIAG_LEDS),A		;To show we got this far.
	BIT	2,A	
	JR	Z,VGA_SIGNON
	BIT	0,A	
	JR	Z,TTY_SIGNON		;USB/TTY output cannot tolorate some control characters
	BIT	3,A	
	JR	Z,TTY_SIGNON		;Printer output cannot tolorate some control characters
	JR	PROP_SIGNON		;Else, default Propeller Console I/O

PROP_SIGNON:				;LED's 0,1 & 2 ON, indicates Propeller for Console
	LD	HL,SIGNON_MSG		;Clear screen etc. if propeller
	CALL	PRINT_STRING		;Have a valid Stack, so now we can use CALL
TTY_SIGNON: 
	LD	HL,SIGNON_MSG1		
	CALL	PRINT_STRING
	JR	SIGNON_DONE

VGA_SIGNON:
	CALL	VGA_CLEAR_SCREEN	;Note this will setup the RAM POINTER to VGA_BASE
	LD	A,0FFH
	OUT	(VGA_COLOR),A		;Port to set text color to white
	DEC	A			;Note No characters visible until color is set.
	OUT	(VGA_CURSOR_Y),A	;0, Curaor at top RH corner. Y goes:- 0,1,2,3,...80	
	INC	A
	OUT	(VGA_CURSOR_X),A	;1, Cursor X goes:- 1,2,3,...79,0
	
;	JP	TEST
	
	LD	HL,SIGNON_MSG1		
	CALL	PRINT_STRING
;	JP	TEST
	
SIGNON_DONE:
	CALL	CRLF
	LD	HL,SP_MSG		;Print 'SP=$'
	CALL	PRINT_STRING

	PUSH	IX			;SP is stored from above in [IX]
	POP	HL
	CALL	HLSP			;Print HL/SP 

	LD	HL,IOBYTE_MSG		;Print ' IOBYTE=$'
	CALL	PRINT_STRING
	
	IN	A,(IOBYTE)		;Show IOBYTE bits. 
	CALL	BITS1			;Signon done for any one of the 3 video output options.
	
	CALL	CRLF			;Then CRLF
	CALL	CSTS			;Check if garbage at keyboard
	CALL	NZ,CI			;If so flush it

	LD	A,80H			;Initilize the S100Computers I/O Board
	OUT	(SPEED_PORT),A		;Lower CPU sped to 2MHz
	CALL	INIT_SCC_A		;Initilize the Zilog 8530-A (XModem I/O)
	CALL	INIT_SCC_B		;Initilize the Zilog 8530-B (Speech synthizer)
	LD	HL,SPEAK_CLEAR		;Clear speaker
	CALL	SPEAK
	XOR	A			;Initilize the S100Computers I/O Board
	OUT	(SPEED_PORT),A		;Back to 25Mhz CPU speed
	
	IN	A,(DIAG_LEDS)
	OR	A,01000000B		;FLAG PROGRESS (Ready to go, 2 LED's On)
	OUT	(DIAG_LEDS),A

	CALL	CSTS			;Flush CI status port
	
	LD	a,READcfg8255		;Config 8255 chip (10010010B), read mode on return
	OUT	(IDEportCtrl),a		;Config 8255 chip, READ mode

	LD	A,0			;Zero in LBA paramaters for IDE/CF Card after a reset	
	LD	(@SEC),A		
	LD	(@SEC+1),A		
	LD	(@TRK),A
	LD	(@TRK+1),A
	LD	HL,buffer		;set default DMA address for IDE/CF Card to RAM_BASE
	LD	(@DMA),HL	
					;IF S100 Bus MSDOS Support board is present. Inactivate 8259A -- just in case.
	LD	A,MasterICW1		;Initilize the 8259A PIC Controller (;EDGE triggered, 4 bytes, single Master,ICW4 needed)
	OUT	(MASTER_PIC_PORT),A
	LD	A,MasterICW2		;Ints starts at 20H in RAM (IBM-PC uses 8X4 = 20H)
	OUT	(MASTER_PIC_PORT+1),A
	LD	A,MasterICW4		;No slaves above, so 8259 does not expect ICW3
	out	(MASTER_PIC_PORT+1),A
	LD	A,11111111b		;Allow no interrupts to the 8259A with Z80.
	out	(MASTER_PIC_PORT+1),A

	LD	A,0H			;IMSAI PIO Board and this board. Clear Printer strobe
	OUT	(PRINTER_OUT),A	
	LD	A,0FFH			
	OUT	(PRINTER_STROBE),A	
	LD	A,0H			
	OUT	(PRINTER_STROBE),A	
	LD	A,0FFH			
	OUT	(PRINTER_STROBE),A	

	IN	A,(DIAG_LEDS)
	OR	A,00100000B		;FLAG PROGRESS (Ready to go, 3 LED's On)
	OUT	(DIAG_LEDS),A


;-------THIS IS THE START ON THE MAIN SBC-Z80 LOOP--------------------------------

;TEST:	CALL	ECHO1
;	JP	COLD

START:	LD	DE,START
	PUSH	DE			;EXTRA UNBALANCED POP & [DE] WOULD END UP IN [PC]
	CALL	CRLF
	LD	C,BELL			;A BELL HERE WILL SIGNAL WHEN JOBS ARE DONE
	CALL	CO
	LD	C,'-'
	CALL	CO
	LD	C,'>'	   
	CALL	CO

STARO:	CALL	CSTS			;Need to check status first because IOBYTE may have changed
	JR	Z,STARO
	CALL	TI			;Main loop. SBC-Z80 will stay here until cmd.
	AND	7FH
	JR	Z,STARO
	SUB	'@'			;Commands @ to Z only
	RET	M
	CP	1BH			;A-Z only
	RET	NC
	ADD	A,A
	LD	HL,TBL
	ADD	A,L
	LD	L,A
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	LD	C,02H
	JP	(HL)			;JUMP TO COMMAND TO COMMAND (from TABLE)
;
;
INTS_OK:
	LD	HL,IM1_MSG		;Print 'IM1 Mode Interrupts ON'
	CALL	PRINT_STRING
	EI				;Enable interrupts
	IM1				;Set to Z80 INT Mode 1 (ALL interrupts to 38H in RAM)
;	LD	A,0EDH			;Put an Z80 INT RETURN at 38H in RAM just in case we false trigger
;	LD	(38H),A
;	LD	A,4DH			
;	LD	(39H),A
	JP	BEGIN		

;PRINT MAIN SBC-Z80 MENU ON CRT

KCMD:	LD	HL,SIGNON_MSG1		;Menu Option "K", List Menu Options
	CALL	PRINT_STRING
	LD	HL,SMSG_SP		;Signon speech message
	CALL	SPEAK
	LD	HL,MAIN_MENU_MSG	;Then Menu Message
	JP	PRINT_STRING

SWAP_RAM:				;Swap lowest 32K of RAM 
	LD	HL,SWAP_RAM_MSG		
	CALL	PRINT_STRING
	CALL	PCHK			;Get a character
	CP	A,'0'
	JR	Z,Page0
	CP	A,'1'
	JR	Z,Page1
	JP	INVALID_DATA
	
Page0:	LD	A,0
	OUT	(RAM_BANK),A		;Output to this board bit 0 to switch lower 32K of RAM
	LD	HL,PAGE0_MSG		
	CALL	PRINT_STRING
	JP	BEGIN1
Page1:	LD	A,1
	OUT	(RAM_BANK),A		;Output to this board bit 0 to switch lower 32K of RAM
	LD	HL,PAGE1_MSG		;Note if this code is being tested in low RAM system will hang here.
	CALL	PRINT_STRING
	JP	BEGIN1
	
INVALID_DATA:
	LD	HL,Invalid_Msg
	CALL	PRINT_STRING
	JP	BEGIN		

			
;SEND MESSAGE TO CONSOL MESSAGE IN [HL],LENGTH IN [B]

TOM:	LD	C,(HL)
	INC	HL
	CALL	CO
	DJNZ	TOM
	RET

USB_PRINT_STRING:			;Special print srring for Xmodem
	IN	A,(IOBYTE)		;If transfer is via USB port - skip status updates
	BIT	0,A
	RET	Z
PRINT_STRING:				;A ROUTINE TO PRINT OUT A STRING @ [HL]
	LD	A,(HL)			;UP TO THE FIRST '$'.
	INC	HL			
	CP	'$'
	RET	Z
	LD	C,A
	CALL	CO			;Note will go to Propeller Console OR USB Port
	JR	PRINT_STRING


;ABORT IF ESC AT CONSOL, PAUSE IF ^S AT CONSOL

CCHK:	CALL	CSTS			;FIRST IS THERE ANYTHING THERE
	RET	Z
	CALL	CI
	CP	'S'-40H
	JR	NZ,CCHK1
CCHK2:	CALL	CSTS			;WAIT HERE UNTIL ANOTHER INPUT IS GIVEN
	JR	Z,CCHK2
CCHK1:	CP	ESC
	RET	NZ			;RETURN EXECPT IF ESC

;RESTORE SYSTEM AFTER ERROR

ERROR:	CALL	MEMSIZ			;GET RAM AVAILABLE - WORKSPACE IN [HL]
	LD	SP,HL			;SET STACK UP IN WORKSPACE AREA
	LD	C,'*'
	CALL	CO
	JP	START

;PRINT HIGHEST RAM MEMORY FROM BOTTOM

SIZE:	CALL	MEMSIZ			;RETURNS WITH [HL]= RAM AVAILABLE-WORKSPACE

LFADR:	CALL	CRLF

;PRINT [HL] AND A SPACE

HLSP:	PUSH	HL
	PUSH	BC
	CALL	LADR			;Print [HL] with no space afterwards
	LD	C,SPACE
	CALL	CO
	POP	BC
	POP	HL
	RET

;PRINT A SPACE
PSPACE:	LD	C,SPACE
	CALL	CO
	RET

;CONVERT HEX TO ASCII

CONV:	AND	0FH
	ADD	A,90H
	DAA 
	ADC	A,40H
	DAA 
	LD	C,A
	call	CO
	RET

;;;;;;;

;GET TWO PARAMETERS AND PUT THEM IN [HL] & [DE] THEN CRLF

EXLF:	CALL	HEXSP	
	POP	DE
	POP	HL

;SEND TO CONSOL CR/LF

CRLF:	PUSH	AF
	PUSH	BC
	LD	C,CR
	CALL	CO
	LD	C,LF
	CALL	CO
	POP	BC
	POP	AF
	RET
	

;PUT THREE PARAMETERS IN [BC] [DE] [HL] THEN CR/LF

EXPR3:	INC	C			 ;ALREADY HAD [C]=2 FROM START
	CALL	HEXSP
	CALL	CRLF
	POP	BC
	POP	DE
	POP	HL
	RET 
	
;GET ONE PARAMETER

EXPR1:	LD	C,01H
HEXSP:	LD	HL,0000
EX0:	CALL	TI
EX1:	LD	B,A
	CALL	NIBBLE
	JR	C,EX2X
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	OR	L
	LD	L,A
	JR	EX0
EX2X:	EX	(SP),HL
	PUSH	HL
	LD	A,B
	CALL	QCHK
	JR	NC,SF560
	DEC	C
	RET	Z
SF560:	JP	NZ,ERROR
	DEC	C
	JR	NZ,HEXSP
	RET 
EXF:	LD	C,01H
	LD	HL,0000H
	JR	EX1

;RANGE TEST ROUTINE CARRY SET = RANGE EXCEEDED

HILOX:	CALL	CCHK
	CALL	HILO
	RET	NC
	POP	DE			;DROP ONE LEVEL BACK TO START
	RET 
HILO:	INC	HL			;RANGE CHECK SET CARRY IF [DE]=[HL]
	LD	A,H
	OR	L
	SCF
	RET	Z
	LD	A,E
	SUB	L
	LD	A,D
	SBC	A,H
	RET 

;PRINT [HL] ON CONSOL

LADR:	LD	A,H
	CALL	LBYTE
	LD	A,L
LBYTE:	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	SF598
	POP	AF
SF598:	CALL	CONV			;Convert to ASCII AND print it
	RET

;THIS IS A CALLED ROUTINE USED TO CALCULATE TOP OF RAM IS USED BY
;THE ERROR ROUTINE TO RESET THE STACK. 
;Returns top of RAM in [HL]

MEMSIZ:	PUSH	BC			;SAVE [BC]
MEMSZ1:	LD	HL,0FFFFH		;START FROM THE TOP DOWN
MEMSZ2:	LD	A,(HL)
	CPL 
	LD	(HL),A
	CP	(HL)
	CPL 				;PUT BACK WHAT WAS THERE
	LD	(HL),A
	JP	Z,GOTTOP
	DEC	H			;TRY 100H BYTES LOWER
	JR	MEMSZ2			;KEEP LOOKING FOR RAM
GOTTOP:	POP	BC			;RESTORE [BC]
	RET 

NIBBLE:	SUB	30H
	RET	C
	CP	17H
	CCF
	RET	C
	CP	LF
	CCF
	RET	NC
	SUB	07H
	CP	LF
	RET

COPCK:	LD	C,'-'
	CALL	CO

PCHK:	CALL	TI

;TEST FOR DELIMITERS

QCHK:	CP	SPACE
	RET	Z
	CP	','
	RET	Z
	CP	CR
	SCF
	RET	Z
	CCF
	RET 


;KEYBOARD HANDELING ROUTINE (WILL NOT ECHO CR/LF)
;IT CONVERTS LOWER CASE TO UPPER CASE FOR LOOKUP COMMANDS
;ALL OTHERE CHARACTERS ARE ECHOED ON CONSOL

TI:	CALL	CI
	CP	CR
	RET	Z
	PUSH	BC
	LD	C,A
	CALL	CO
	LD	A,C
	POP	BC
	CP	40H			;LC->UC
	RET	C
	CP	7BH
	RET	NC
SF754:	AND	5FH
	RET 

GETHL:	PUSH	BC			;Return a HEX value in [HL]
	LD	C,1			;1 paramater
	CALL	HEXSP
	POP	HL
	POP	BC
	RET


;DISPLAY 8 BITS OF [A] (No registers changed)

BITS1:	PUSH	DE			
	PUSH	BC
	LD	E,A
	CALL	BITS
	POP	BC
	POP	DE
	RET

;DISPLAY 8 BITS OF [A] (B & C registers changed)

BITS:	LD	B,08H			
	CALL	PSPACE
SF76E:	SLA	E
	LD	A,18H
	ADC	A,A
	LD	C,A
	CALL	CO
	DJNZ	SF76E
	RET 
	
;MEMORY MAP PROGRAM CF.DR.DOBBS VOL 31 P40.
;IT WILL SHOW ON CONSOL TOTAL MEMORY SUMMARY OF RAM,PROM, AND NO MEMORY

MEMMAP:
	CALL	CRLF
	LD	HL,0
	LD	B,1
MAP1:	LD	E,'R'			;PRINT R FOR RAM
	LD	A,(HL)
	CPL
	LD	(HL),A
	CP	(HL)
	CPL
	LD	(HL),A
	JR	NZ,MAP2
	CP	(HL)
	JR	Z,PRINT
MAP2:	LD	E,'p'
MAP3:	LD	A,0FFH
	CP	(HL)
	JR	NZ,PRINT
	INC	L
	XOR	A
	CP	L
	JR	NZ,MAP3
	LD	E,'.'
PRINT:	LD	L,0
	DEC	B
	JR	NZ,NLINE
	LD	B,16
	CALL	CRLF
	CALL	HXOT4
NLINE:	LD	A,SPACE
	CALL	OTA
	LD	A,E
	CALL	OTA
	INC	H
	JR	NZ,MAP1
	CALL	CRLF
	CALL	CRLF
	JP	START

;16 HEX OUTPUT ROUTINE

HXOT4:	LD	C,H
	CALL	HXO2
	LD	C,L
HXO2:	LD	A,C
	RRA
	RRA
	RRA
	RRA
	CALL	HXO3
	LD	A,C
HXO3:	AND	0FH
	CP	10
	JR	C,HADJ
	ADD	A,7
HADJ:	ADD	A,30H
OTA:	PUSH	BC
	LD	C,A
	CALL	CO			;SEND TO CONSOL
	POP	BC
	RET

;DISPLAY MEMORY IN HEX

DISP:	CALL	EXLF			;GET PARAMETERS IN [HL],[DE]
	LD	A,L			;ROUND OFF ADDRESSES TO XX00H
	AND	0F0H
	LD	L,A
	LD	A,E			;FINAL ADDRESS LOWER HALF
	AND	0F0H
	ADD	A,10H			;FINISH TO END 0F LINE
SF172A:	CALL	LFADR
SF175A:	CALL	BLANK

;	CALL	CSTS			;For debugging		
;	CALL	PROP_CI
					
	LD	A,(HL)
	CALL	LBYTE
	CALL	HILOX
	LD	A,L
	AND	0FH
	JR	NZ,SF175A
	LD	C,TAB			;INSERT A TAB BETWEEN DATA
	CALL	CO
	LD	B,4H			;ALSO 1 SPACE
TA11:	LD	C,SPACE
	CALL	CO
	DJNZ	TA11

	IN	A,IOBYTE		;For some reason ASCII display only on VGA display is
	BIT	2,A			;not working. Skip it for now!
	JR	Z,SF172A
		
	LD	B,16			;NOW PRINT ASCII (16 CHARACTERS)
	PUSH	DE			;TEMPORLY SAVE [DE]
	LD	DE,0010H
	SBC	HL,DE
	POP	DE
T11:	LD	A,(HL)
	AND	7FH
	CP	' ' 			;FILTER OUT CONTROL CHARACTERS'
	JR	NC,T33
T22:	LD	A,'.'
T33:	CP	07CH
	JR	NC,T22
	LD	C,A			;SET UP TO SEND
	CALL	CO
	INC	HL
	DJNZ	T11			;REPEAT FOR WHOLE LINE
	JR	SF172A


;INSPECT AND / OR MODIFY MEMORY

SUBS:	LD	C,1
	CALL	HEXSP
	POP	HL
SF2E3:	LD	A,(HL)
	CALL	LBYTE
	LD	C,'-'
	CALL	CO
	CALL	PCHK
	RET	C
	JR	Z,SF2FC
	CP	5FH
	JR	Z,SF305
	PUSH	HL
	CALL	EXF
	POP	DE
	POP	HL
	LD	(HL),E
	LD	A,B
	CP	CR
	RET	Z	
SF2FC:	INC	HL
SF2FD:	LD	A,L
	AND	07H
	CALL	Z,LFADR
	JR	SF2E3
SF305:	DEC	HL
	JR	SF2FD


;Print a space on screen

BLANK:	PUSH	BC			
	PUSH	HL
	LD	C,' '
	CALL	CO
	POP	HL
	POP	BC
	RET

;FILL A BLOCK OF MEMORY WITH A VALUE

FILL:	CALL	EXPR3
SF1A5:	LD	(HL),C
	CALL	HILOX
	JR	NC,SF1A5
	POP	DE
	JP	START

;GO TO A RAM LOCATION
					
GOTO:	LD	C,1			;SIMPLE GOTO FIRST GET PARMS.
	CALL	HEXSP
	CALL	CRLF
	POP	HL			;GET PARAMETER PUSHED BY EXF
	JP	(HL)

; GET OR OUTPUT TO A PORT

QUERY:	CALL	PCHK
	CP	'O'			;OUTPUT TO PORT
	JR	Z,OUT_PORT
	CP	'I'			;INPUT FROM PORT
	JP	Z,IN_PORT
	LD	C,'*'
	JP	CO			;WILL ABORT IF NOT 'I' OR 'O'

IN_PORT:
	LD	C,1			;IN Port
	CALL	HEXSP
	POP	BC
	IN	A,(C)
	JP	BITS1
;
OUT_PORT:
	CALL	HEXSP			;OUT Port
	POP	DE
	POP	BC
	OUT	(C),E
	RET


; MEMORY TEST

RAMTEST:
	PUSH	HL
	PUSH	BC
	LD	HL,RAM_TEST_MSG
	CALL	PRINT_STRING
	POp	BC
	POP	HL
	CALL	EXLF
SF200:	LD	A,(HL)
	LD	B,A
	CPL 
	LD	(HL),A
	XOR	(HL)
	JR	Z,SF215
	PUSH	DE
	LD	D,B
	LD	E,A			;TEMP STORE BITS
	CALL	HLSP
	CALL	BLANK
	LD	A,E
	CALL	BITS1
	CALL	CRLF
	LD	B,D
	POP	DE
SF215:	LD	(HL),B
	CALL	HILOX
	JR	SF200

;MOVE A BLOCK OF MEMORY TO ANOTHER LOCATION

MOVE:	CALL	EXPR3
SF21E:	LD	A,(HL)
	LD	(BC),A
	INC	BC
	CALL	HILOX
	JR	SF21E

;VERIFY ONE BLOCK OF MEMORY WITH ANOTHER
 
VERIFY:	CALL	EXPR3
VERIO:	LD	A,(BC)
	CP	(HL)
	JR	Z,SF78E
	PUSH	BC
	CALL	CERR
	POP	BC
SF78E:	INC	BC
	CALL	HILOX
	JR	VERIO
	RET
;
CERR:	LD	B,A
	CALL	HLSP
	LD	A,(HL)
	CALL	LBYTE
	CALL	BLANK
	LD	A,B
	CALL	LBYTE
	JP	CRLF

ECHO:	LD	HL,ECHO_MSG
	CALL	PRINT_STRING	
ECHO1:	CALL	CI			;Routeen to check keyboard etc.
	CP	'C'-40H			;Loop until  ^C
	RET	Z
	LD	C,A
	CALL	CO
	JR	ECHO1


;READ ASCII FROM MEMORY

TYPE:	CALL	EXLF
SF30B:	CALL	LFADR
	LD	B,56
SF310:	LD	A,(HL)
	AND	7FH
	CP	SPACE
	JR	NC,SF319
SF317:	LD	A,2EH
SF319:	CP	7CH
	JR	NC,SF317
	LD	C,A
	CALL	CO
	CALL	HILOX
	DJNZ	SF310
	JR	SF30B


;	Display all active IO input ports in the system
;
INPORTS:
	LD	HL,ALL_PORTS
	CALL	PRINT_STRING	
	LD	B,0			;Now loop through all ports (0-FF)
	LD	D,6			;Display 6 ports across
	LD	E,0FFH			;Will contain port number
LOOPIO:	LD	C,E
	LD	A,E
	CP	A,SW_TMA0		;Inputting here will switch out the Z80 to 8086/80286
	JR	Z,SKIP			;Skip because we don't want that right now
;
	IN	A,(C)			;Remember  [ZASMB does not work with this opcode,SLR is OK]
	CP	A,0FFH			;No need for 0FF's
	JR	Z,SKIP
	LD	H,A			;store port data in H for below
	LD	A,E			;Need to print port # first
	CALL	LBYTE			;Print port number
	LD	C,'-'
	CALL	CO
	LD	C,'>'
	CALL	CO
	LD	A,H			;get back port data
	CALL	LBYTE			;print it
	LD	C,TAB
	CALL	CO
	DEC	D			;6 ports per line
	JR	NZ,SKIP
	LD	D,6
	CALL	CRLF
SKIP:	DEC	E			;Next Port
	DJNZ	LOOPIO
	CALL	CRLF
	RET

;
;
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> XMODEM ROUTINES <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

;This code will read a download file from another computer (usually a PC) sent via a serial port and place
;it in RAM at a specified location.  The file must be sent via the XModem protocol. On PC's there are
;many programs that do this. The "Absolute Telnet" program (by Celestial Software) is what I use.

BOOT_XMODEM:
	LD	HL,MODEM_SIGNON		;Send Modem signon message
	CALL	PRINT_STRING
					
	LD	HL,0			;SP to HL
	ADD	HL,SP			
	LD	DE,40H			;Drop 40H bytes below to be safe
	SBC	HL,DE
	PUSH	HL
	POP	IX			;Will store data  below in RAM 40H bytes below SP to be safe
					
	XOR	A,A			;Initilize flags
	LD	(IX+RECVD_SECT_NO),A
	LD	(IX+SECTNO),A
	LD	(IX+ERRCT),A
					
	LD	HL,MODEM_RAM_LOC	;Get RAM location for where to place code
	CALL	PRINT_STRING
	LD	C,1
	CALL	HEXSP			;Get 16 bit value, put on stack
	POP	IY			;DMA Value now in IY
	CALL	CRLF
					
	CALL	INIT_SCC_A		;INITITIALIZE THE SCC SERIAL PORT A
				
	LD	B,1			;TIMEOUT DELAY
	CALL	RECV			;GOBBLE UP GARBAGE CHARS FROM THE LINE

RECV_LOOP:				; ---- MAIN RECIEVE LOOP ----
	XOR	A,A			;GET 0
	LD	(IX+ERRCT),A		;INITIAL ERROR COUNT SET TO 0
RECV_HDR:
	LD	HL,RMSG
	CALL	PRINT_STRING
	LD	A,(IX+SECTNO)		;Get current sector number
	INC	A
	CALL	LBYTE			;Show Sector Number on Console

	LD	HL,MODEM_RAM_MSG	;"H.  IF OK, will write to RAM location"
	CALL	PRINT_STRING
	PUSH	IY
	POP	HL			;IY to HL
	CALL	LADR			;Show DMA Address
	CALL	CRLF

	LD	B,5			;5 SEC TIMEOUT
	CALL	RECV
	JP	NC,RHNTO		;IF ALL OK (NO TIMEOUT), THEN DROP DOWN TO RHNTO TO GET DATA

RECV_HDR_TIMEOUT:
	CALL	TOUT			;PRINT TIMEOUT

RECV_SECT_ERR:				;PURGE THE LINE OF INPUT CHARS
	LD	B,1			;1 SEC W/NO CHARS
	CALL	RECV
	JP	NC,RECV_SECT_ERR	;LOOP UNTIL SENDER DONE
	LD	A,NAK
	CALL	SEND			;SEND NAK

	LD	A,(IX+ERRCT)
	INC	A
	LD	(IX+ERRCT),A
	CP	A,MODEM_ERR_LIMIT
	JP	C,RECV_HDR
			
	CALL	CHECK_FOR_QUIT
	JP	Z,RECV_HDR
	LD	HL,BAD_HEADER_MSG
	CALL	PRINT_STRING
	JP	START

CHECK_FOR_QUIT:				;MULTIPLE ERRORS, ASK IF TIME TO QUIT
	XOR	A,A			;GET 0
	LD	(IX+ERRCT),A		;RESET ERROR COUNT
	LD	HL,QUITM
	CALL	PRINT_STRING

CI3:	IN 	A,S100_CONSOL_STATUS		;NEED CONSTAT TO CLEAN UP SHIFT KEYS ETC
	AND	A,02H
	JP	Z,CI3
	IN	A,S100_CONSOL_IN
	AND	A,7FH
	PUSH	AF			;SAVE CHAR
	CALL	CRLF
	POP	AF
	CP	A,'R'
	RET	Z			;RETURN IF RETRY
	CP	A,'r'
	RET	Z
	CP	A,'Q'			;QUIT?
	JP	NZ,LCQ
	OR	A,A			;TURN OFF ZERO FLAG
	RET
LCQ:	CP	A,'q'
	JP	NZ,CHECK_FOR_QUIT
	OR	A,A			;TURN OFF ZERO FLAG
	RET
								
RHNTO:	CP	A,SOH			;GOT CHAR - MUST BE SOH
	JP	Z,GOT_SOH		;Z IF OK
	OR	A,A			;00 FROM SPEED CHECK?
	JP	Z,RECV_HDR
	CP	A,EOT
	JP	Z,GOT_EOT
					;DIDN'T GET SOH - 
	CALL	LBYTE
	LD	HL,ERRSOH
	CALL	PRINT_STRING
	JP	RECV_SECT_ERR

GOT_SOH:
	LD	B,1
	CALL	RECV
	JP	C,RECV_HDR_TIMEOUT
	LD	D,A			;D=BLK #
	LD	B,1
	CALL	RECV			;GET CMA'D SECT #
	JP	C,RECV_HDR_TIMEOUT
	CPL
	CP	A,D			;GOOD SECTOR #?
	JP	Z,RECV_SECTOR
								
	LD	HL,ERR2			;GOT BAD SECTOR #
	CALL	PRINT_STRING
	JP	RECV_SECT_ERR


RECV_SECTOR:				;Sector is OK, so read data and place in RAM
	LD	A,D			;GET SECTOR #
	LD	(IX+RECVD_SECT_NO),A
	LD	C,0			;INIT CKSUM
	LD	E,80H			;Sector Byte Count
	PUSH	IY
	POP	HL			;DMA address (IY) to HL
					
RECV_CHAR:
	LD	B,1			;1 SEC TIMEOUT
	CALL	RECV			;GET CHAR
	JP	C,RECV_HDR_TIMEOUT
	LD	(HL),A			;STORE CHAR
	INC	HL		
	DEC	E			;Next sector byte
	JP	NZ,RECV_CHAR

					;VERIFY CHECKSUM
	LD	D,C			;SAVE CHECKSUM
	LD	B,1			;TIMEOUT
	CALL	RECV			;GET CHECKSUM
	JP	C,RECV_HDR_TIMEOUT
	CP	A,D			;CHECK
	JP	NZ,RECV_CKSUM_ERR

					;GOT A SECTOR, WRITE IF = 1+PREV SECTOR
	LD	A,(IX+RECVD_SECT_NO)
	LD	B,A			;SAVE IT
	LD	A,(IX+SECTNO)		;GET PREV
	INC	A			;CALC NEXT SECTOR #
	CP	B			;MATCH?
	JP	NZ,DO_ACK
	LD	(IX+SECTNO),A		;UPDATE SECTOR #
DO_ACK:	LD	A,ACK
	CALL	SEND
				
	PUSH	HL			;ALL OK SO SAVE DMA Address in IY
	POP	IY			
	JP	RECV_LOOP		;Back to Top recieve loop

RECV_CKSUM_ERR:
	LD	HL,ERR3
	CALL	PRINT_STRING
	JP	RECV_SECT_ERR

GOT_EOT:
	LD	A,ACK			;ACK THE EOT
	CALL	SEND
	JP	XFER_CPLT

TOUT:	LD	HL,TIME_OUT_MSG		;PRINT TIMEOUT MESSAGE
	CALL	PRINT_STRING
	LD	A,(IX+ERRCT)
	CALL	LBYTE		
	CALL	CRLF
	RET
	
	
XFER_CPLT:				;DONE - CLOSE UP SHOP
	LD	HL,MODEM_DONE_MSG
	CALL	PRINT_STRING
	JP	START

;----------------------------------------------------
;   XMODEM SERIAL PORT GET CHARACTER ROUTINE
;----------------------------------------------------

RECV:	PUSH	AF
	IN	A,IOBYTE
	BIT	0,A
	JR	NZ,RECV_MDM
	JR	RECV_USB

RECV_MDM:
	POP	AF
	PUSH	DE			;SAVE D,E
	LD	A,5H			;Lower RTS line
	OUT	MODEM_CTL_PORT,A	;Sel Reg 5
	LD	A,11101010B		;EAH
	OUT	MODEM_CTL_PORT,A
	NOP
	NOP
MSEC:	LD	DE,0BBBBH		;1 SEC DCR COUNT
MWTI:	IN	A,MODEM_CTL_PORT
	AND	A,MODEM_RECV_MASK
	CP	A,RECV_READY
	JP	Z,MCHAR			;GOT CHAR
	DEC	E			;COUNT DOWN
	JP	NZ,MWTI			;FOR TIMEOUT
	DEC	D
	JP	NZ,MWTI
	DEC	B			;DCR # OF SECONDS
	JP	NZ,MSEC			;MODEM TIMED OUT RECEIVING
	POP	DE			;RESTORE D,E
	SCF				;CARRY SHOWS TIMEOUT
	RET

	;GOT MODEM CHAR
MCHAR:	IN	A,MODEM_DATA_PORT
	POP	DE			;RESTORE DE
	PUSH	AF			;CALC CHECKSUM
	ADD	A,C
	LD	C,A
	POP	AF
	OR	A,A			;TURN OFF CARRY TO SHOW NO TIMEOUT
	RET

RECV_USB:
	POP	AF
	PUSH	DE			;SAVE D,E
MSECU:	LD	DE,0BBBBH		;1 SEC DCR COUNT

MWTIU:	IN 	A,(USB_STATUS_PORT)	;NEED CONSTAT TO CLEAN UP SHIFT KEYS ETC
	AND	01H
	JR	NZ,MCHARU		;GOT CHAR
	DEC	E			;COUNT DOWN
	JP	NZ,MWTIU		;FOR TIMEOUT
	DEC	D
	JP	NZ,MWTIU
	DEC	B			;DCR # OF SECONDS
	JP	NZ,MSECU		;MODEM TIMED OUT RECEIVING
	POP	DE			;RESTORE D,E
	SCF				;CARRY SHOWS TIMEOUT
	RET

	;GOT MODEM CHAR
MCHARU:	IN	A,(USB_DATA_PORT)
	POP	DE			;RESTORE DE
	PUSH	AF			;CALC CHECKSUM
	ADD	A,C
	LD	C,A
	POP	AF
	OR	A,A			;TURN OFF CARRY TO SHOW NO TIMEOUT
	RET
					
;----------------------------------------------------
;   XMODEM SERIAL PORT SEND CHARACTER ROUTINE
;----------------------------------------------------

SEND:	PUSH	AF
	ADD	A,C			;CALC CKSUM
	LD	C,A
	IN	A,IOBYTE
	BIT	0,A
	JR	NZ,SEND_MDM
	JR	SEND_USB

SEND_MDM:
SENDW:	IN	A,MODEM_CTL_PORT	;Don't worry PC is always fast enough!
	AND	A,MODEM_SEND_MASK
	CP	A,SEND_READY
	JP	NZ,SENDW
	POP	AF			;GET CHAR
	OUT	MODEM_DATA_PORT,A
				
					;Raise RTS line to prevent the next character arriving
	LD	A,5H			;while the Z80 is busy processing info
	OUT	MODEM_CTL_PORT,A	;Sel Reg 5
	LD	A,11101000B		;E8H
	OUT	MODEM_CTL_PORT,A
	RET

SEND_USB:
	IN	A,(USB_STATUS_PORT)	;USB Port for Console OUT
	AND	00000010B
	JR	NZ,SEND_USB		;Not yet ready - busy transmitting, try again
	POP	AF			;Recover char to send
	OUT	(USB_DATA_PORT),A
	RET
;
;
;
;
;XXXXXX <<<<<<<<<<<<<<<<<<<<<< MAIN CONSOL I/O ROUTINES >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
;
CO:	IN	A,IOBYTE		;Find out where we send data
	BIT	3,A
	CALL	Z,LO			;SEND OUTPUT TO PRINTER AS WELL			
	IN	A,IOBYTE		;Find out where we send data
	BIT	2,A	
	JR	Z,VGA_CO
	BIT	0,A	
	JR	Z,USB_CO		;USB port for output
	JR	PROP_CO			;For now everything else Propeller Console Board
	
PROP_CO:
	IN	A,(S100_CONSOL_STATUS)	;PROPELLER VIDIO BOARD PORT
	AND	4H
	JR	Z,PROP_CO		;Not yet ready, try both outputs
	LD	A,C
	CP	07H			;IS IT A BELL
	JP	Z,BELL1			;Special case
	CP	0H			;SD BOARD CANNOT TAKE A NULL!
	RET	Z
	OUT	(S100_CONSOL_OUT),A
	RET

LOX:	CALL	CO			;OUTPUT TO BOTH PRINTER & CONSOLE
	CALL	LO
	RET

BELL1:	LD	A,06H			;SEND A BELL
	OUT	(S100_CONSOL_OUT),A
	LD	A,0FH
	CALL	DELAY
	LD	A,07H
	OUT	(S100_CONSOL_OUT),A
	RET


DELAY:	DEC	A			;GENERAL COUNT DOWN TIME DELAY
	RET	Z			;LENGTH SET IN [A]
	PUSH	AF
	LD	A,05H
MORE:	DEC	A
	PUSH	AF
	XOR	A
MORE2:	DEC	A
	JR	NZ,MORE2
	POP	AF
	JR	NZ,MORE
	POP	AF
	JR	DELAY


USB_CO:	IN	A,(USB_STATUS_PORT)	;USB Port for Console OUT
	AND	00000010B
	JR	NZ,USB_CO		;Not yet ready - busy transmitting, try again
	LD	A,C
	AND	7FH			;Always 7 bits only.
	OUT	(USB_DATA_PORT),A
	RET

;--------------------------------------VGA VIDEO ROUTINES ---------------------------------------

VGA_CO:	
	PUSH	BC			;Only A is changed
	PUSH	DE
	PUSH	HL
	LD	A,C			;Character output to VGA Display
;	CALL	PROP_CO			;For Diagnostic display only
	LD	A,C
	CP	A,CR			;Is it a CR, will convert to CR/LF
	JP	Z,DO_CR
	CP	A,LF			;Is it a LF, Skip for now
	JP	Z,DO_LF	
	CP	A,FF			;Is it a FF (0CH,^L), if so clear screen 
	JP	Z,DO_FF	
	CP	A,BACKS			;Back Space
	JP	Z,DO_BS
	CP	A,TAB			;Is it a TAB, skip for now
	JP	Z,DO_TAB
	CP	A,BELL			;Is it a BELL, skip for now
	JP	Z,DO_BELL
	CP	A,1FH			;Only real characters
	JR	NC,NORMAL_CHAR
	JP	VGA_CO_DONE		;SKIP anything else
	
NORMAL_CHAR:				;All other (real) ASCII characters
	LD	HL,(RAM_POINTER)	;RAM POINTER to [HL] & UPDATE RAM POINTER X,Y
	LD	(HL),C			;Drop down character
	INC	HL			;Move to next RAM position
	LD	(RAM_POINTER),HL

	LD	A,(LOCAL_X)		;Get current RAM X position
	INC	A			;Point to next position
	CP	A,50H			;Is it past EOL, LOCAL X cursor goes 0,2,3...4FH (80)
	JR	NZ,NOT_EOL		;LOCAL X goes 0,2,3...4F
	
	LD	A,(LOCAL_Y)		;At EOL,  LOCAL Y goes 0,2,3...26H (36)
	CP	A,TOTAL_VGA_LINES	;Are we on the bottom line
	JP	Z,BOTTOM_LINE	

	LD	A,0			;Not Bottom line, so MOVE to next line
	LD	(LOCAL_X),A
	LD	A,(LOCAL_Y)
	INC	A
	LD	(LOCAL_Y),A
	JR	DONE_NORMAL_CHARACTER
NOT_EOL:
	LD	(LOCAL_X),A
	JR	DONE_NORMAL_CHAR

BOTTOM_LINE:				;Special case situation for bottom line (38)
	CALL	VGA_SCROOL
	LD	A,(LOCAL_X)		;Get current RAM X position
	CP	A,4FH			;Is it the last character on last line
	JP	Z,LAST_CHAR		;If so special case
	LD	A,0			;Not last char on last line so just move everything up one line
	LD	(LOCAL_X),A
	JR	DONE_NORMAL_CHAR
LAST_CHAR:
	LD	A,0			;Move to start of line
	LD	(LOCAL_X),A
	LD	HL,VGA_BASE + (TOTAL_VGA_LINES * 50H)  ;Point to bottom LHS corner
	LD	(RAM_POINTER),HL
	JR	DONE_NORMAL_CHAR
	
DONE_NORMAL_CHAR:
	LD	A,(LOCAL_X)
	INC	A			;Cursor X goes 1,2,3...4F,0!
	CP	A,50H
	JR	NZ,NOT_50
	LD	A,0
NOT_50:	OUT	(VGA_CURSOR_X),A
	LD	A,(LOCAL_Y)		;Cursor Y goes 0,1,2,3...4F
	OUT	(VGA_CURSOR_Y),A
VGA_CO_DONE:	
	POP	HL
	POP	DE
	POP	BC
	LD	A,C
	RET

	
DO_CR:	LD	A,(LOCAL_X)
	LD	HL,(RAM_POINTER)
DO_CR1:	OR	A,A
	JR	Z,DONE_DO_CR
	DEC	A
	DEC	HL
	JR	DO_CR1
DONE_DO_CR:
	LD	(RAM_POINTER),HL
	LD	(LOCAL_X),A
	JR	DONE_NORMAL_CHAR
	
	
DO_LF:	LD	A,(LOCAL_Y)
	LD	HL,(RAM_POINTER)
	LD	DE,50H			;Add 80 character positions
	CP	A,TOTAL_VGA_LINES	;My VGA Monitor works best with no more than 38 lines
	JR	Z,LF_SCROOL
	ADD	HL,DE
	LD	(RAM_POINTER),HL
	INC	A
	LD	(LOCAL_Y),A
	JR	DONE_NORMAL_CHAR
LF_SCROOL:
	CALL	VGA_SCROOL	
	JR	DONE_NORMAL_CHAR


DO_TAB:	LD	A,(LOCAL_X)		;Expand out tabs so line numbering is 1,2,3,4.....80
	CP	A,4FH
	JR	NZ,DO_TAB1		;Not at end of line, expand tabs
	LD	C,CR			;At end of line, do CR/FL
	CALL	VGA_CO
	LD	C,LF			;At end of line, do CR/FL
	CALL	VGA_CO
	JP	DONE_NORMAL_CHAR
DO_TAB1:	
	LD	D,A			;Store for below	
	INC	A
	AND	A,00000111B		;Max 8 spaces for tabs
	LD	B,A
	LD	A,8
	SUB	A,B			
	LD	B,A			;1 to 8 spaces in loop below								
DO_8:	LD	C,SPACE			;Print a space
	CALL	VGA_CO
	DJNZ	DO_8
	JP	DONE_NORMAL_CHAR


DO_BS:	LD	A,(LOCAL_X)		;Get current RAM X position
	OR	A,A
	JP	Z,VGA_CO_DONE		;NO BS for first character, just return
	LD	HL,(RAM_POINTER)	;RAM POINTER to [HL] & BACKUP RAM POINTER X,Y
	DEC	HL
	LD	(RAM_POINTER),HL	
	LD	A,SPACE
	LD	(HL),A
	LD	A,(LOCAL_X)		;Get current RAM X position
	DEC	A
	LD	(LOCAL_X),A
	IN	A,(VGA_CURSOR_X)
	DEC	A
	OUT	(VGA_CURSOR_X),A
	JP	VGA_CO_DONE	

	
DO_FF:	
	CALL	VGA_CLEAR_SCREEN	; Clear VGA Screen, put cursor at Top LH corner
	JP	DONE_NORMAL_CHAR
	
DO_DEL:
	LD	HL,(RAM_POINTER)	;RAM POINTER to [HL]
	LD	A,SPACE
	LD	(HL),A
	JP	VGA_CO_DONE	


DO_BELL:POP	DE			;Skip for now
	POP	HL
	POP	BC
	LD	A,C
	RET
	
VGA_SCROOL:
	LD	DE,VGA_BASE		;Start from E000H
	LD	HL,VGA_BASE+50H
	LD	BC,0BE0H + 50H		;Total number of bytes to move for 38 lines + one blank line
	LDIR				;Z80 block move ((DE++)<-(HL++), BC--
	RET
	
	
	
VGA_CLEAR_SCREEN:			; Clear VGA Screen, put cursor ate Top LH corner
	LD	HL,VGA_BASE
	LD	DE,(VGA_BASE_END + 51H )- VGA_BASE		;<--- Do NOT clear all the way up to EFFFH because
CLEAR1:	LD	A,SPACE						;     this Z80 monitor stack will get overwritten
	LD	(HL),A						;Note we clear an extra line for screen scrolls
	INC	HL
	DEC	DE
	LD	A,E
	CP	A,0
	JR	NZ,CLEAR1		; Continue until DE = 0
	LD	A,D
	CP	A,0
	JR	NZ,CLEAR1
	XOR	A,A
	LD	(LOCAL_X),A		;0, RAM X offset
	LD	(LOCAL_Y),A		;0, RAM Y offset
	OUT	(VGA_CURSOR_Y),A	;0, Cursor Y at top RH corner. Cursor Y goes:- 0,1,2,3,...80	
	INC	A
	OUT	(VGA_CURSOR_X),A	;1, Cursor X goes:- 1,2,3,...79,0
	LD	HL,VGA_BASE
	LD	(RAM_POINTER),HL
	RET
	



;<<<<<<<<<<<<<<<<<<< MAIN CONSOL STATUS ROUTINE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

CSTS:	IN	A,IOBYTE		;Find out where we send data
	BIT	1,A	
	JR	Z,PS2_CSTS
	BIT	2,A	
	JR	Z,VGA_CSTS
	BIT	0,A	
	JR	Z,USB_CSTS		;USB port
	JR	PROP_CSTS		;For now everything else Propeller Console Board
	
PROP_CSTS:
	IN	A,(S100_CONSOL_STATUS)
	AND	02H
	JP	Z,NO_CSTS		;Zero if nothing
GOT_CSTS:
	XOR	A
	DEC	A			;RETURN WITH 0FFH IN [A] IF SOMETHING
	RET
NO_CSTS:
	XOR	A			
	RET				;RETURN WITH 0 IN A IF NOTHING THERE

USB_CSTS:
	IN	A,(USB_STATUS_PORT)
	AND	01H
	JR	Z,NO_CSTS		;Zero if nothing
	JR	GOT_CSTS

PS2_CSTS:
	IN	A,(PS2_STATUS_PORT)
	AND	01H
	JR	Z,NO_CSTS		;Zero/Low if nothing
	JR	GOT_CSTS
	
VGA_CSTS:
	JP	PROP_CSTS

;<<<<<<<<<<<<<<<<<<<< MAIN CONSOL INPUT ROUTINE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

CI:	IN	A,IOBYTE		;Find out where we send data
	BIT	1,A	
	JR	Z,PS2_CI
	BIT	2,A	
	JR	Z,VGA_CI
	BIT	0,A	
	JR	Z,USB_CI		;USB port
	JR	PROP_CI		;For now everything else Propeller Console Board
	
PROP_CI:
	IN 	A,(S100_CONSOL_STATUS)	;NEED CONSTAT TO CLEAN UP SHIFT KEYS ETC
	AND	02H
	JR	Z,PROP_CI		;Wait until something there
	IN	A,(S100_CONSOL_IN)
	AND	7FH
	RET

USB_CI:
	IN 	A,(USB_STATUS_PORT)	;NEED CONSTAT TO CLEAN UP SHIFT KEYS ETC
	AND	01H
	JR	Z,USB_CI		;Wait until something there
	IN	A,(USB_DATA_PORT)
	AND	7FH			;Always 7 bits only.
	RET
	
PS2_CI:
	IN 	A,(PS2_STATUS_PORT)	;NEED CONSTAT TO CLEAN UP SHIFT KEYS ETC
	AND	01H
	JR	Z,PS2_CI		;Wait until something there
	IN	A,(PS2_DATA_PORT)
	AND	7FH			;Always 7 bits only.
	RET


VGA_CI:
	JP	PROP_CI
	
	
;>>>>>>>>>>>>>>>>>>>> MAIN PRINTER OUTPUT ROUTINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
LO:	LD	A,C
	OUT	(PRINTER_OUT),A		;Send Data
	LD	A,0FFH			;Setup strobe High -> Low -> High
	OUT	(PRINTER_STROBE),A
	XOR	A	 		;Send STROBE FOR CENTRONICS
	OUT	(PRINTER_STROBE),A

	PUSH	BC
	LD	B,0FFH
LO1:	IN	A,(PRINTER_STATUS)   	
	AND	00000001B    		;Z if last char was acknowledged
	JR	Z,LO2
	DJNZ	LO1			;Try 255 times
	
LO2:	POP	BC
	LD	A,0FFH			;Raise strobe again
	OUT	(PRINTER_STROBE),A
	JP	LSTAT			;Remain until printer is NOT Busy
	

FLUSH:	LD	C,FF			;Send a Form Feed to LaserJet Printer
	CALL	LO			;This forces a partial page to be printed
	RET


;>>>>>>>>>>>>>>>>>>>>>> PRINTER STATUS ROUTINE <<<<<<<<<<<<<<<<<<<<<<<<
LSTAT:	PUSH	BC
	LD	B,0FFH
LSTAT1:	IN	A,(PRINTER_STATUS)  
	AND	A,00000011B
	JR	Z,LSTAT2
	DJNZ	LSTAT1			;Keep trying
	POP	BC
	XOR	A
	DEC	A			;BUSY = HIGH, or ACK = HIGH,  NON-ZERO FLAG, PRINTER BUSY
	RET	
LSTAT2:	POP	BC
	XOR	A	     		;BUSY = LOW, ACK = LOW,  ZERO FLAG, PRINTER READY
	RET	
	

NOT_DONE:
	LD	HL,NOT_DONE_MSG		;Routine not written yet
	CALL	PRINT_STRING
	RET

;>>>>>>>>>>>>>>>>>>>>>> SPEECH OUTPUT <<<<<<<<<<<<<<<<<<<<<<<<

SPEAKOUT:
	XOR	A,A			;Will try 256 times, then timeout
SPXXX:	PUSH	AF
	IN	A,(BCTL)		;(A0), Is SCC RX Buffer empty
	AND	04H
	JR	NZ,SENDS		;NZ if ready to recieve character
	POP	AF
	DEC	A
	JR	NZ,SPXXX
	RET
SENDS:	POP	AF
	LD	A,C
	OUT	(BDTA),A		;(A2), Send it
	RET
;
;SPEAKTOMM THIS IS A ROUTINE TO SEND A STRING TO TALKER [HL] AT STRING
SPEAK:	LD	A,80H			
	OUT	(SPEED_PORT),A		;Set Low 2Mhz speed CPU clock
SPEAK2:	LD	A,(HL)
	CP	'$'
	JR	Z,SPEAK1
	LD	C,A
	CALL	SPEAKOUT
	INC	HL
	JR	SPEAK2
SPEAK1:	LD	C,0DH			;MUST END WITH A CR
	CALL	SPEAKOUT

	LD	B,0			;Hardware seems to need a time delay at 25MHz clock
SPEAK3:	DJNZ	SPEAK3
SPEAK4:	DJNZ	SPEAK4
	XOR	A			
	OUT	(SPEED_PORT),A		;back to high speed
	RET
;
;
;
;-----------------------------------------------
;S100Computers Serial I/O Board Initilization
;Note Zilog SCC serial port A will be set to 38,400 Baud initially (for XModem etc).
;Note Zilog SCC serial port B will be set to 19,200 Baud initially (for speech synthesizer).
;The FPGA Z80 module does not seem to have a working OTIR instruction. Do it 8080 style

INIT_SCC_A:
	LD	A,ACTL			;Program Channel A
	LD	C,A
	LD	B,0EH			;<<< Byte count for OTIR below
;	LD	B,10H
	LD	HL,SCCINIT_A
	OTIR				;<<< Z80 Code working with corrected Microcomputer.vhd
	RET
	
OUT_LOOP_A:				;Old 8080 approach
	LD	A,(HL)
	OUT	(ACTL),A
;	PUSH	BC			;For debugging display bytes sent
;	CALL	LBYTE
;	POP	BC
	INC	HL
	DJNZ	OUT_LOOP_A
	RET

	
INIT_SCC_B:
	LD	A,BCTL			;Program Channel B
	LD	C,A
	LD	B,0EH			;<<< Byte count for OTIR below
;	LD	B,10H
	LD	HL,SCCINIT_B
	OTIR				;;<<< Z80 Code working with corrected Microcomputer.vhd
	RET
					
OUT_LOOP_B:				;Old 8080 approach
	LD	A,(HL)
	OUT	(BCTL),A
;	PUSH	BC			;For debugging display bytes sent
;	CALL	LBYTE
;	POP	BC
	INC	HL
	DJNZ	OUT_LOOP_B
	RET
;
;
;	
SCCINIT_A:
	DB	04H			;Point to WR4
	DB	44H			;X16 clock,1 Stop,NP
	DB	03H			;Point to WR3
	DB	0C1H			;Enable reciever, Auto Enable, Recieve 8 bits	
;	DB	0E1H			;Enable reciever, No Auto Enable, Recieve 8 bits (for CTS bit)	
	DB	05H			;Point to WR5
	DB	0EAH			;Enable, Transmit 8 bits
	DB	0BH			;Set RTS,DTR, Enable. Point to WR11
	DB	56H			;Recieve/transmit clock = BRG
	DB	0CH			;Point to WR12
;	DB	40H			;Low Byte 2400 Baud 
;	DB	1EH			;Low Byte 4800 Baud 
;	DB	0EH			;Low Byte 9600 Baud 
;	DB	06H			;Low byte 19,200 Baud 
	DB	02H			;Low byte 38,400 Baud <<<<<<<<<<< XModem I/O
;	DB	00H			;Low byte 76,800 Baud  
	DB	0DH			;Point to WR13
	DB	00H			;High byte for Baud
	DB	0EH			;Point to WR14
	DB	01H			;Use 4.9152 MHz Clock. Note SD Systems uses a 2.4576 MHz clock, enable BRG
	DB	0FH			;Point to WR15
	DB	00H			;Generate Int with CTS going high

SCCINIT_B:
	DB	04H			;Point to WR4
	DB	44H			;X16 clock,1 Stop,NP
	DB	03H			;Point to WR3
	DB	0C1H			;Enable reciever, Auto Enable, Recieve 8 bits	
	DB	05H			;Point to WR5
	DB	0EAH			;Enable, Transmit 8 bits
	DB	0BH			;Set RTS,DTR, Enable. Point to WR11
	
	DB	56H			;Recieve/transmit clock = BRG
	DB	0CH			;Point to WR12
	DB	06H			;Low byte 19,200 Baud <<<<<<<<<<< Note Speech synthizer defaults to this value
	DB	0DH			;Point to WR13
	DB	00H			;High byte for Baud
	DB	0EH			;Point to WR14
	DB	01H			;Use 4.9152 MHz Clock. Note SD Systems uses a 2.4576 MHz clock, enable BRG
	DB	0FH			;Point to WR15
	DB	00H			;Generate Int with CTS going high
	
;-----------------------------------------------------------------------------------------------------
;
SIGNON_MSG:	DB SCROLL,QUIT,NO_ENH,FAST,BELL,'$'		
SIGNON_MSG1:	DB CR,LF,LF,'FPGA SBC-Z80 FPGA-ROM MONITOR (@ F000H) V3.07a J.Monahan, 8/2/2024$' 	

MAIN_MENU_MSG:	DB	CR,LF,LF
  		DB	'A=Memmap     D=Show RAM   E=Echo Text   F=Fill RAM '
		DB	CR,LF
		DB	'G=Goto       I=IDE Menu   J=Test RAM    K=Menu'
		DB	CR,LF
		DB	'L=RTC        M=Move RAM   QI,O=Port     N=Load RomWBW (SD)'
		DB	CR,LF
		DB	'R=Ports      S=Subs RAM   T=RAM ASCII   P=Load RomWBW (IDE)' 
		DB	CR,LF
		DB      'V=Verify RAM X=XModem     Y=Swap RAM    U=SD Card' 
		DB	CR,LF
		DB	'@=Flush Printer           Z=Top Of RAM',CR,LF,LF,'$'

SPEAK_CLEAR	DB	CR,CR,CR,'$'
SMSG_SP:	DB	'THE Z80 ROM MONITOR VERSION 3.0$'
	
SP_MSG		DB	'SP=$'
IOBYTE_MSG	DB	' IOBYTE=$'
ALL_PORTS	DB	CR,LF,'Active I/O Ports:-',CR,LF,'$'
Invalid_Msg	DB	CR,LF,BELL,'Invalid Data',CR,LF,'$'
NOT_DONE_MSG	DB	CR,LF,BELL,'Routine not written!',CR,LF,'$'
RAM_TEST_MSG    DB	CR,LF,'Enter RAM range (xxxx,yyyy)',CR,LF,'$'
ECHO_MSG	DB	CR,LF,'Type characters. (^C to abort)',CR,LF,'$'

MODEM_SIGNON:	DB	CR,LF,'Get a File from a PC',CR,LF
		DB	'Zilog SCC Ports A1H & A3H. Requires RTS & CTS, 38,400 Baud.',CR,LF,'$'
TIME_OUT_MSG:	DB	'TIMEOUT $'

MODEM_SCC_MSG:	DB	'SCC Port A to 38,400 Baud.',CR,LF,'$'
RMSG:		DB	'WAITING FOR SECTOR #$'
ERRSOH:		DB	'H RECEIVED, NOT SOH',0DH,0AH,'$'
ERR2:		DB	'++BAD SECTOR # IN HDR',0DH,0AH,'$'
ERR3:		DB	'++BAD CKSUM ON SECTOR',0DH,0AH,'$'
QUITM:		DB	0DH,0AH,'MULTIPLE ERRORS.'
		DB	0DH,0AH,'TYPE Q TO QUIT, R TO RETRY:$'
MODEM_DONE_MSG:	DB	13,10,'TRANSFER COMPLETE$'
BAD_HEADER_MSG:	DB	CR,LF,'INVALID HEADER.',0DH,0AH,'$'
MODEM_RAM_MSG:	DB	'H. If OK will write to RAM at $'

MODEM_RAM_LOC:	DB	CR,LF,'Enter RAM location (xxxxH +CR): $'

SWAP_RAM_MSG	DB	CR,LF,'Swap Lowest 32K of RAM. (Enter 0 or 1)$'
PAGE0_MSG	DB	CR,LF,'Page 0 RAM active',CR,LF,'$'
PAGE1_MSG	DB	CR,LF,'Page 1 RAM active',CR,LF,'$'
IM1_MSG		DB	CR,LF,'IM1 Mode Interrupts ON',CR,LF,'$'	

