;	SBC-MON2.Z80  This is a stripped down version of the main MASTER-Z80 (and SBC-MON.Z80 monitor) programs 
;	for use with the S100 bus Z80-FPGA SBC. It will not work with other Z80 CPU Boards without modifications.
; 
;	Assemble and SLR's Z80ASM Assembler (Can also use the Cromemco Assembler)
;	Use:- Z80ASM SBC-MON FH
;
;	NOTE. This board initially utilizes an 16K FPGA ROM module (which behaves the same as a "real" 28C128 EEPROM) 
;	Normally the code resides in four 4K "pages" that can be swapped in one at a time to the Z80 code space
;	at F000H-FFFFH. Currently only 3 pages are used. The code in each page is completely self contained and does
;	not access code in othe pages. All pqages have a common jump table and address switching routine at the start 
;	of each page.  The location of these jumps etc. must be idential in allpages.
;	The pages are named Z80-MONA.Z80, Z80-MONB.Z80 & Z80-MONC.Z80
;
;	To assemble under windows...
;	Load Altair.EXE in Windows CMD box
;	do cpm3
;	I:
;	I:>Submit SBC-MONC.SUB etc.
;
;	There is a submit file for each page.
;
;	SBC-MON2.HEX  is written back to the same windows folder that the PC file "altair.exe" is in.

;	The 2 (or later 3) HEX files need to be combined and loaded into the FPGA as one large .HEX file.
;	Please see here for a discription as to how to do this.
;	http://s100computers.com/My%20System%20Pages/FPGA%20Z80%20SBC/FPGA%20Z80%20SBC.htm
;
;	Recent History...
;
;	V1.0	4/30/2019	Started with the modified MASTER.Z80 V5.1 Monitor. Removed the page switching menu option.
;	V1.01	7/20/2019	Added printer output
;	V2.0	8/21/2019	Added a third page for SD Cards
;	V2.1	7/6/2023	Added speech synthesizer output, activate Z8530 ports
;	V2.2	7/9/2023	Add OTIR long hand in 8080 code format to initilize Z8530s
;	V2.23	7/10/2023	Added clock speed adjustment for Z8530 serial ports
;	V2.31	7/30/2023	Corrected OTIR code in Microcomputer.bsf file
;	V2.31b  7/31/2023       Total code checkout/rebuild
;	V3.0	8/6/2023	Added 4th ROM page with RTC diagnoatic code
;	V3.01	5/22/2024	[WBW] Supported USB Serial on all pages
;	V3.02	6/26/2024	[WBW] Converted IDE CPM Boot to RomWBW load
;	V3.03	7/4/2024	[WBW] Switched RTC SPI to 8-bit interface
;	V3.04	7/5/2024	[WBW] Enhanced SD Card protocol handling
;	V3.05	7/12/2024	[WBW] Converted SD CPM Boot to RomWBW load
;
FALSE		EQU	0
TRUE		EQU	NOT FALSE
;
;--------------------------------------------------------
;        Basic MONITOR Routines		Page #0/Power-up
;        IDE Routines			Page #1
;        SD Card Routines		Page #2
;--------------------------------------------------------
;
;
MONITOR_BASE	EQU	0F000H		;Start of monitor after a reset								
RAM_BASE	EQU	0C000H		;Default location of RAM buffer area for IDE/CF card diagnostic routines
					;Can be changed with "D" IDE menu command

SCROLL		EQU	01H					
BELL		EQU	07H
SPACE		EQU	20H
TAB		EQU	09H		;TAB ACROSS (8 SPACES FOR SD-BOARD)
CR		EQU	0DH
LF		EQU	0AH
FF		EQU	0CH
QUIT		EQU	11H		;Turns off any screen enhancements (flashing, underline etc).
NO_ENH		EQU 	17H		;Turns off whatever is on
FAST		EQU	10H		;High speed scroll
ESC		EQU	1BH
DELETE		EQU	7FH
BACKS		EQU	08H
CLEAR		EQU	1AH		;TO CLEAR SCREEN
RST7		EQU	38H		;RST 7 (LOCATION FOR TRAP)
NN		EQU	0H		;[I] INITIAL VALUE
SOH		EQU	1		;For XModem etc.
EOT		EQU	4
ACK		EQU	6
NAK		EQU	15H
;

; Note on the mapping below: The DIP switches on the physical board connect to GND with pull up resistors 
; OPEN/OFF switches are '1's and CLOSED/ON DIP switches are '0's
;
; BIT MAP OF IOBYTE BASE_PORT + 6H:- X X X X  X X X X  (if xxxxx111= 111 = CONSOLE IN/OUT DATA for all Console IO board
;			             | | | |  | | | |..............  110 = will use onboard USB chip for ALL Console I/O
;			             | | | |  | | |................  x0x = will force/override onboard FPGA code, to PS2 keyboard input 
;			             | | | |  | |..................  0xx = will force/override, VGA for Console output
;			             | | | |  |....................  0 = Send Console Data to Printer as well as console.
;			             | | | |.......................  Unused			
;			             | | |.........................  Unused							 
;			             | |...........................  Unused
;			     	     |.............................  0 Low Speed Clock for CPU (2mHz).
;
;
;

BASE_PORT	EQU	30H		;Note by using 30H we can use software already on CF-CARDS for the Z80 SBC board
USB_STATUS_PORT	EQU	BASE_PORT+4H	;Status port for USB console input port
USB_DATA_PORT	EQU	BASE_PORT+5H	;Data port for USB console port
IOBYTE		EQU	BASE_PORT+6H	;See above

PS2_STATUS_PORT	EQU	02H		;PS2 Keyboard input port
PS2_DATA_PORT	EQU	03H

DIAG_LEDS	EQU	06H		;LED BAR of FPGA Board (and LED Bar on V3 SMB if present)
SW_TMAX		EQU	0EEH		;OUTPUT BIT 0 HIGH FROM THIS PORT LOWERS DMA0* on V3 SMB (if present)
					;OUTPUT BIT 1 HIGH FROM THIS PORT LOWERS DMA1* on V3 SMB (if present)
					;OUTPUT BIT 2 HIGH FROM THIS PORT LOWERS DMA2* on V3 SMB (if present)
					;OUTPUT BIT 3 HIGH FROM THIS PORT LOWERS DMA3* on V3 SMB (if present) 
SW_TMA0	EQU	0EDH			;INPUT FROM THIS PORT LOWERS DMA0* (SWITCHES IN THE 8088,8086,80286 or 80386 boards)


					;Note these DMA lines are only used in master/slave changes. Not normally used here.

RAM_BANK	EQU	36H		;Port to switch Low/High 32K RAM Page
ROM_PAGE	EQU	07H		;Port to inactivate the the onboard FPGA ROM or switch in/out one of the four 4k pages.

MPGSEL_0	EQU	78H		; Z2 MEM MGR BANK 0 PAGE SELECT REG (0K-16K)
MPGSEL_1	EQU	79H		; Z2 MEM MGR BANK 1 PAGE SELECT REG (16K-32K)
MPGSEL_2	EQU	7AH		; Z2 MEM MGR BANK 2 PAGE SELECT REG (32K-48K)
MPGSEL_3	EQU	7BH		; Z2 MEM MGR BANK 3 PAGE SELECT REG (48K-64K)
MPGENA		EQU	7CH		; Z2 MEM MGR PAGING ENABLE REGISTER (BIT 0, WRITE ONLY)

PRINTER_STROBE	EQU	0C6H		;PRINTER DATA STROBE PORT OUT
PRINTER_STATUS	EQU	0C7H		;PRINTER STATUS PORT IN
PRINTER_OUT	EQU	0C7H		;PRINTER DATA PORT OUT

SPEED_PORT	EQU	07H		;Bit 7 HIGH forces CPU to SLOW State
	
VGA_CURSOR_X	EQU	0C0H		;Port to set VGA video cursor
VGA_CURSOR_Y	EQU	0C1H
VGA_COLOR	EQU	0C2H		;Port to set text color
VGA_BASE	EQU	0E000H		;The VGA text will reside from E000H to EC7FH
VGA_BASE_END	EQU	0EC7FH		;Last character at bottom RHS
TOTAL_VGA_LINES	EQU	38		;26H
RAM_POINTER	EQU	VGA_BASE+0FFEH	;Will store VGA RAM Pointer at very top or its RAM.
LOCAL_X		EQU	VGA_BASE+0FFDH
LOCAL_Y		EQU	VGA_BASE+0FFCH

MODEM_SEND_MASK	EQU	4
SEND_READY	EQU	4		;VALUE WHEN READY
MODEM_RECV_MASK	EQU	1
RECV_READY	EQU	1		;BIT ON WHEN READY
MODEM_ERR_LIMIT	EQU	8		;Max number of Modem serial port re-reads aborting
MODEM_RTS_DELAY	EQU	1		;Time to check Modem RTS line (See XMODEM_LOAD & P_XMODEM_LOAD). Not critical.

RECVD_SECT_NO	EQU	0H		;IX Offset for XModem Recieved Sector Number
SECTNO		EQU	1H		;IX Offset for XModem CURRENT SECTOR NUMBER 
ERRCT		EQU	2H		;IX Offset for XModem ERROR COUNT
					
;****************************************************************************************************************
;
;		 EQUATES FOR OTHER POSSIBLE BOARDS IN THE S100 BUS SYSTEM
;               (Note. If the board is not present the code will ignore the hardware)
;
;****************************************************************************************************************
    					;FOR S100 BUS 8259A (If Present)
MASTER_PIC_PORT	EQU	20h		;Hardware port the 8259A (two ports 20H & 21H)
MasterICW1	equ	00010111B	;EDGE triggered, 4 bytes, single Master,ICW4 needed
MasterICW2	equ	8H		;Base address for 8259A Int Table (IBM-PC uses 8X4 = 20H)
MasterICW3	equ	0H		;No slave
MasterICW4	equ	00000011B	;No special mode, non buffer, Auto EOI, 8086.  ;<<<<,

;-------------- S100Computers PROPELLER CONSOLE_IO (OR SD SYSTEMS VIDIO BOARD) FOR CONSOLE INPUT & OUTPUT

S100_CONSOL_STATUS	EQU	0H	;Note will utilize this board if IOBYTE bits 0 & 1 are ZERO (or bit 5 is 1).	
S100_CONSOL_IN		EQU	1H
S100_CONSOL_OUT		EQU	1H

;-------------- S100Computers I/O BOARD PORT ASSIGNMENTS  (A0-AC)

BCTL		EQU	0A0H		;CHANNEL B CONTROL  (SPEECH PORT) ;<--- Adjust as necessary, 
BDTA		EQU	0A2H		;CHANNEL B DATA
ACTL		EQU	0A1H		;CHANNEL A CONTROL (MODEM_CTL_PORT)		
ADTA		EQU	0A3H		;CHANNEL A DATA (MODEM_DATA_PORT)

MODEM_CTL_PORT	EQU	0A1H	 	;A1H (Note modem I/O will be on CHANNEL A. Speaker on CHANNEL B
MODEM_DATA_PORT	EQU	0A3H		;A3H 

;-------------- S100Computers IDE HARD DISK CONTROLLER COMMANDS ETC. (for Z80_MONB.Z80) -------------------------------------

IDEPORTA	EQU	030H		;Lower 8 bits of IDE interface (8255)
IDEPORTB	EQU	031H		;Upper 8 bits of IDE interface
IDEPORTC	EQU	032H		;Control lines for IDE interface
IDEPORTCTRL	EQU	033H		;8255 configuration port

READCFG8255	EQU	10010010b	;Set 8255 IDEportC to output, IDEportA/B input
WRITECFG8255	EQU	10000000b	;Set all three 8255 ports to output mode

;IDE control lines for use with IDEportC.  

IDEA0LINE	EQU	01H		;direct from 8255 to IDE interface
IDEA1LINE	EQU	02H		;direct from 8255 to IDE interface
IDEA2LINE	EQU	04H		;direct from 8255 to IDE interface
IDECS0LINE	EQU	08H		;inverter between 8255 and IDE interface
IDECS1LINE	EQU	10H		;inverter between 8255 and IDE interface
IDEWRLINE	EQU	20H		;inverter between 8255 and IDE interface
IDERDLINE	EQU	40H		;inverter between 8255 and IDE interface
IDERSTLINE	EQU	80H		;inverter between 8255 and IDE interface

;Symbolic constants for the IDE Drive registers, which makes the
;code more readable than always specifying the address bits

REGDATA		EQU	IDEcs0line					;(08H)
REGERR		EQU	IDEcs0line + IDEa0line				;(09H)
REGSECCNT	EQU	IDEcs0line + IDEa1line				;(0AH)
REGSECTOR	EQU	IDEcs0line + IDEa1line + IDEa0line		;(0BH)
REGCYLINDERLSB	EQU	IDEcs0line + IDEa2line				;(0CH)
REGCYLINDERMSB	EQU	IDEcs0line + IDEa2line + IDEa0line		;(0DH)
REGSHD		EQU	IDEcs0line + IDEa2line + IDEa1line		;(0EH)
REGCOMMAND	EQU	IDEcs0line + IDEa2line + IDEa1line + IDEa0line	;(0FH)
REGSTATUS	EQU	IDEcs0line + IDEa2line + IDEa1line + IDEa0line
REGCONTROL	EQU	IDEcs1line + IDEa2line + IDEa1line
REGASTATUS	EQU	IDEcs1line + IDEa2line + IDEa1line + IDEa0line

;IDE Command Constants.  These should never change.

COMMANDrecal	EQU	10H
COMMANDread	EQU	20H
COMMANDwrite	EQU	30H
COMMANDinit	EQU	91H
COMMANDid	EQU	0ECH
COMMANDspindown	EQU	0E0H
COMMANDspinup	EQU	0E1H


; IDE Status Register:
;  bit 7: Busy	1=busy, 0=not busy
;  bit 6: Ready 1=ready for command, 0=not ready yet
;  bit 5: DF	1=fault occured insIDE drive
;  bit 4: DSC	1=seek complete
;  bit 3: DRQ	1=data request ready, 0=not ready to xfer yet
;  bit 2: CORR	1=correctable error occured
;  bit 1: IDX	vendor specific
;  bit 0: ERR	1=error occured

SEC$SIZE	EQU	512		;Assume sector size as 512. (Not tested for other sizes)
MAXSEC		EQU	3DH		;Sectors per track for CF my Memory drive, Kingston CF 8G. (For CPM format, 0-3CH)
					;This translates to LBA format of 1 to 3D sectors, for a total of 61 sectors/track.
					;This CF card actully has 3F sectors/track. Will use 3D for my CPM3 system because
					;my Seagate drive has 3D sectors/track. Don't want different CPM3.SYS files around
					;so this program as is will also work with a Seagate 6531 IDE drive

MAXTRK		EQU	0FFH		;CPM3 allows up to 8MG so 0-256 "tracks"
BUFFER$ORG	EQU	3000H		;<----- Will place all sector data here

CPM$BOOT$COUNT	EQU	12		;Allow up to 12 CPM sectors for CPMLDR
CPMLDR$ADDRESS	EQU	100H		;Load the CPMLDR at 100H in RAM 

RAM_BANK	EQU	36H		;Port to switch Low/High 32K RAM Page
ROM_PAGE	EQU	07H		;Set ROM page of FPGA ROM

SD_CARD_BASE	EQU	06CH

SD_DATA_OUT	EQU	SD_CARD_BASE		; (6CH) Data TO port to SD CONTRROLLER
SD_DATA_IN	EQU	SD_CARD_BASE		; (6CH) Data TO port to SD CONTRROLLER
SD_SPEED_PORT	EQU	SD_CARD_BASE+1		; (6DH) HIGH TO READ/WRITE SECTORS WITH HIGH SPEED SPI CLOCK
SD_CS_PORT	EQU	SD_CARD_BASE+2		; (6EH) SD Select Port
SD_STATUS	EQU	SD_CARD_BASE+2		; (6EH) SD Status Port
SD_RW		EQU	SD_CARD_BASE+3		; (6FH) Port to pulse SPI Read/Write

HIGH_SPEED	EQU	01H;		; Select SPI 10MHz CLK
LOW_SPEED	EQU	00H		; Select SPI 4KHz CLK (Default on startup)
SD_CS_A		EQU	0FEH		; CS* select bit for SD Card drive A
SD_CS_B		EQU	0FDH		; CS* select bit for SD Card drive B 
SD_BUSY		EQU	01H;
SD_CS_READ_A	EQU	80H;		; Bit to test if Drive A CS* pin is low (not currently used)
SD_CS_READ_B	EQU	40H;		; Bit to test if Drive B CS* pin is low (not currently used)

MONITOR		EQU	0F000H		; Location of Z80 ROM monitor when done.

DEBUG		EQU	TRUE		; If TRUE all sector reads will display the actual 512 bytes of data read
SPI_SPEED	EQU	TRUE		; If TRUE all sector Reads/Writes will switch the SPI interface from 40Khz to 10MHz

; -------------------------- RAM usage for IDE & RTC Routines (in Z80_MONB.Z80,Z80_MONC.Z80 & Z80_MOND.Z80)  ---------------

IDBUFFER	EQU	RAM_BASE+ 1000H		;512 Bytes @ (C000H+1000H = D000H) for CF-Card paramaters 
buffer		EQU	RAM_BASE		;Default DMA buffer at C000H

@DMA		EQU	RAM_BASE + 1F00H	;Remember Stack is at ~DFF0H
@DRIVE$SEC	EQU	RAM_BASE + 1F02H
@DRIVE$TRK	EQU	RAM_BASE + 1F04H
@SEC		EQU	RAM_BASE + 1F06H
@TRK		EQU	RAM_BASE + 1F08H
@STARTLINEHEX	EQU	RAM_BASE + 1F10H
@STARTLINEASCII	EQU	RAM_BASE + 1F12H
@BYTE$COUNT	EQU	RAM_BASE + 1F14H
@SECTOR$COUNT	EQU	RAM_BASE + 1F16H
@DELAYSTORE	EQU	RAM_BASE + 1F18H

@YEAR:		EQU	RAM_BASE + 1F1AH
@MONTH:		EQU	RAM_BASE + 1F1CH
@DATE:		EQU	RAM_BASE + 1F1EH
@HOURS:		EQU	RAM_BASE + 1F20H
@MINUTES:	EQU	RAM_BASE + 1F22H
@SECONDS:	EQU	RAM_BASE + 1F24H

@CARD_TYPE	EQU	RAM_BASE + 1F26H	;For SD cards
@CURRENT_DRIVE	EQU	RAM_BASE + 1F28H
@SEC_ADDRESS	EQU	RAM_BASE + 1F2AH


;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;-------------------------------- START OF ACTUAL MONITOR @ FOOOH --------------------------------------------------
;//////////////////////////////////////////////////////////////////////////////////////////////////////////////////


ORG		MONITOR_BASE		;<--------<<<<<< LOCATION OF START OF MONITOR, F000H >>>>>>>>>>>>>>>>>>>>>>

;PROGRAM CODE BEGINS HERE

	JP	SD_CARD_MENU		; In theory we should never get here.

;----------------->>> THIS CODE MUST BE AT THE SAME LOCATION AS FOR THE LOW PAGE ROM CODE <<<---------
;
ACTIVATE_1_HIGH_PAGE:			; [B], SWITCH TO HIGH PAGE of ROM (IDE, CPM)
	NOP
	NOP
	NOP
	NOP
	JP	INVALID_MENU_ERROR
	
	
ACTIVATE_2_HIGH_PAGE:			; [C], SWITCH TO HIGH PAGE #2 of ROM (SD card)
	NOP
	NOP
	NOP
	NOP
	JP	HIGH_MENU_2_OPTION	
	
ACTIVATE_3_HIGH_PAGE:			; [D], SWITCH TO HIGH PAGE #3 of ROM (RTC)
	NOP
	NOP
	NOP
	NOP
	JP	INVALID_MENU_ERROR	


ACTIVATE_LOW_PAGE:			; RETURN BACK TO LOW PAGE (00) OF ROM
	LD	A,00H			
	OUT	(ROM_PAGE),A	
	HALT				; Will arrive here only IF no address line switch 
;
;
;----------------------->>> END OF COMMON CODE LOACTIONS <<<----------------------------------
;
HIGH_MENU_2_OPTION:
	CALL	SD_CS_OFF		; Turn off CS on both SD Cards
	LD	HL,buffer		; Default to C000H
	LD	(@DMA),HL
	XOR	A,A
	LD	(@CARD_TYPE),A		; Unknown Card Type so far
	LD	(@CURRENT_DRIVE),A	; Start up with Drive A as current drive	
	LD	A,D			; HIGH PAGE code with 3 in [D] for SD_CARD Menu
	CP	A,3
	JR	Z,SD_CARD_MENU
	CP	A,4			; HIGH PAGE code with 4 in [D] for SD_CARD Boot
	JR	Z,SD_CARD_BOOT
	JR	INVALID_MENU_ERROR	; The only menu options so far

SD_CARD_BOOT:
	CALL	CPM_BOOT
	JP	ACTIVATE_LOW_PAGE

INVALID_MENU_ERROR:
	LD      HL,DATA_ERROR_MSG	; Point Error Message
	CALL	PMSG			; Print string
	JP	ACTIVATE_LOW_PAGE

SD_CARD_MENU:
	LD	HL,SIGNON
	CALL	PMSG

START1:	LD	HL,SIGNON1		; '-------- Main Menu ------Buffer = '
	CALL	PMSG
	LD	HL,(@DMA)
	CALL	PRINT_HL
	LD	HL,SIGNON2		; 'H, Drive = '
	CALL	PMSG
	LD	A,(@CURRENT_DRIVE)
	ADD	A,'A'
	LD	C,A
	CALL	CO
	LD	HL,SIGNON3		; ')'
	CALL	PMSG


		
START2:	CALL	CRLF
	LD	C,'>'	   
	CALL	CO
	CALL	CI
	CP	A,ESC
	JP	Z,ACTIVATE_LOW_PAGE	; RETURN BACK TO LOW PAGE (00) OF ROM
	CP	A,'0'			; Check range (0-6)
	JP	C,DATA_ERROR
	CP	A,'7'			; Check range (0-6)
	JP	NC,DATA_ERROR
	JP	START3

START3:	CP	A,'0'
	CALL	Z,INITILIZE_SD_CARD	; Note: all CALLs will return 0 or 1 so lower
	CP	A,'1'			; down calls will not also be activated
	CALL	Z,READ_SECTOR
	CP	A,'2'
	CALL	Z,READ_BUFFER
	CP	A,'3'
	CALL	Z,WRITE_SECTOR
	CP	A,'4'
	CALL	Z,SET_DMA
	CP	A,'5'
	CALL	Z,CPM_BOOT
	CP	A,'6'
	CALL	Z,GET_DRIVE
	JP	START1

DATA_ERROR:
	LD	HL,DATA_ERROR_MSG	; "Data error"
	CALL	PMSG
	JP	START1
	
	
	
;------------------------------------------------ RESET CARD INTERFACE -----------------------------
INITILIZE_SD_CARD:     
	LD	A,0
	LD	(@CARD_TYPE),A			; Unknown Card Type so far
	LD	HL,RESET_MSG
	CALL	PMSG
	CALL	LOW_SPEED_CLK			; SPI CLK at 40KHz unless told otherewise

	CALL	SEND_SD_RESET			;  Repeatidly send the RESET,  CMD0 (Up to 256 times)
	LD	HL,RESET_ERR_MSG		;  'SD_CARD Interface could NOT be Reset (Status = 
	JP	NZ,CMD_FAIL
	LD	HL,RESET_OK_MSG			; "SD_CARD was reset OK"
	CALL	PMSG

	CALL	SEND_GET_TYPE			; Initilize a Type 2 Card, Get Card Type CMD8. Required for SDHC cards
	LD	HL,SD_TYPE_ERR_MSG		; 'SD Card Type detection failed. (Status = '
	JP	NZ,CMD_FAIL
	
	LD	HL,SD_TYPE_MSG			; 'Detected SD Card Type '
	CALL	PMSG
	LD	A,(@CARD_TYPE)
	CALL	PRINT_A
	CALL	CRLF

	LD	A,(@CARD_TYPE)
	CP	2				; Is it Type 2?
	LD	HL,SD_NOT_SUP_ERR		; 'SD Card Type not supported!'
	JP	NZ,PMSG				; If not, print message and return to menu
	
	CALL	TYPE_2_ACTIVATE			; Type 2 needs special activation
	LD	HL,CMD55_FAIL_MSG		; SD Card Type 2 Initilization failed (CMD55 or CMD41).
	JP	NZ,CMD_FAIL
	LD	HL,CMD41_55_OK_MSG		; 'CMD41 & CMD55 accepted OK. SD Card is now initilized.'
	CALL	PMSG

	CALL	STOP_CRC_CHECK			; Turn off CRC Checking
	LD	HL,CRC_ERROR_MSG		; "Got error trying to turn off CRC checking."
	JP	NZ,CMD_FAIL
	LD	HL,CRC_OFF_MSG			; "Card CRC data checking is now turned off."
	CALL	PMSG

	CALL	SET_SEC_SIZE			; <<<<<<<<<<< Set Sector size to 512 bytes
	LD	HL,SIZE_ERROR_MSG		; "Got error trying set sector size to 512 bytes. (Status = "
	JP	NZ,CMD_FAIL
	LD	HL,SIZE_OK_MSG			; "SD card size set to 512 bytes/sector."
	CALL	PMSG
	XOR	A,A				; Back to main menu
	RET

	
;-------------------------------------------SD CARD RESET -----------------------------------------------------------

SEND_SD_RESET:					; Send Card Reset CMD
	CALL	SD_CS_OFF			; -- Turn off CS on both SD Cards
	LD	B,10H
INIT1:	CALL	SPI_DUMMY_CLOCK
	DJNZ	INIT1
	LD	B,10H				; Send CMD0 (GOIDLE) a few times
INIT2:	CALL	DELAY_5MS
	CALL	DRIVE_CS_ON			; Lower CS on current SD card
	CALL	SPI_DUMMY_CLOCK
	LD	HL,CMD_0			; (CMD0 OR 40H) 
	CALL	SEND_SD_CMD_NOWAIT			
	CALL	READ_RESULT			; Value returned in [A]
	CALL	SD_CS_OFF			; -- Turn off CS on both SD Cards
	CP	A,01H				; Is it OK
	RET	Z				; All OK ret Z set
	DJNZ	INIT2				; Try 256 times
	XOR	A
	DEC	A
	RET					; Error RET NZ

;------------------------------------------------ SEND_IDLE_STATE --------------------------------------

SEND_IDLE_STATE:				; Wait until card is in Idle state		
	LD	B,40				; Try several times
	CALL	DRIVE_CS_ON			; Lower CS on current SD card
SEND_IDLE1:
	LD	HL,CMD_1			; <<<<<<<< SEND CMD1 
	CALL	SEND_SD_CMD	
	CALL	READ_RESULT

	CP	A,0
	JP	Z,SEND_IDLE2			
	DJNZ	SEND_IDLE1			; Need to retry several times.
	CALL	SD_CS_OFF			; -- Turn off CS on both SD Cards
	XOR	A
	DEC	A
	RET					; Error RET NZ
SEND_IDLE2:
	LD	A,0FFH				; Flush with extra 0FF's
	CALL	WRITE_SPI
	LD	A,0FFH				; Flush with extra 0FF's
	CALL	WRITE_SPI

	CALL	SD_CS_OFF			; -- Turn off CS on both SD Cards
	XOR	A
	RET					; Error RET Z
	
;------------------------------------------------ GET CARD VOLTAGE/TYPE --------------------------------------

SEND_GET_TYPE:					; Get Card Voltage/Type
	LD	B,40				; Try several times
GET_TYPE1:
	CALL	DRIVE_CS_ON			; Lower CS on current SD card
	LD	HL,CMD_8			; SEND CMD8 to get Card Voltage
	CALL	SEND_SD_CMD	
	CALL	READ_RESULT
	CP	A,01H				; Expected result for Type 2
	JP	Z,SD_TYPE_2			; If so, handle Type 2 Card
	CP	A,05H				; Expected result for Type 1
	JR	Z,SD_TYPE_1			; Handle Type 1 Card
	CALL	SD_CS_OFF			; Turn off CS on both SD Cards
	DJNZ	GET_TYPE1			; And keep trying till counter exhausted
	JR	SD_TYPE_0
;
SD_TYPE_0:
	; Unknown Card Type
	LD	A,0				; Unknown
	LD	(@CARD_TYPE),A			; Record it
	XOR	A,A
	DEC	A
	RET					; Return failure, NZ

SD_TYPE_1:
	CALL	SD_CS_OFF			; Turn off CS on both SD Cards
	LD	A,1
	LD	(@CARD_TYPE),A			; Record it
	XOR	A,A
	RET					; Return Z

SD_TYPE_2:					; Confirm type 2
	CALL	READ_SPI			; value returned in [A] is 00H
	CALL	READ_SPI			; value returned in [A] is 00H
	CALL	READ_SPI			; value returned in [A] is 01H
	CALL	READ_SPI			; value returned in [A] is AAH
	CALL	SD_CS_OFF			; Turn off CS on both SD Cards
	CP	A,0AAH				; Must be 0AAH for Type 2 cards
	JR	NZ,SD_TYPE_0			; Unexpected vaue, classify as unknown
	LD	A,2				 
	LD	(@CARD_TYPE),A			; Record it
	XOR	A,A				
	RET					; Return Z

NOT_2:	LD	A,0				; Unknown card
	LD	(@CARD_TYPE),A			; Not Type 1 or Type 2 Card
	XOR	A,A
	DEC	A
	RET					; Return NZ
	
	
;  ------------------------------------- AVCTIVATE TYPE 2 CARDS  ---------------------------------

TYPE_2_ACTIVATE:				; Initilize the SD card Type 2 cards with CMD55 & CMD44 Commands
	LD	B,0				; Will try 256 times (some cards take a while)
ACT1:	CALL	DELAY_5MS			; Per spec, 5ms between attempts
	CALL	DRIVE_CS_ON			; Lower CS on current SD card
	LD	HL,CMD_55			; Application specific command next
	CALL	SEND_SD_CMD			
	CALL	READ_RESULT			; value returned in [A]
	CALL	SD_CS_OFF			; -- Turn off CS on both SD Cards
	CP	A,01H				; Correct response is 01H
	JP	Z,ACT2				; Got correct response try CMD41		
	DJNZ	ACT1
	XOR	A
	DEC	A
	RET					; Error RET NZ

ACT2:	CALL	DRIVE_CS_ON			; Turn back on, Lower CS on current SD card (required!)
	LD	HL,CMD_41			
	CALL	SEND_SD_CMD			
	CALL	READ_RESULT			; Value returned in [A]
	CALL	SD_CS_OFF			; -- Turn off CS on both SD Cards
	CP	A,0
	RET	Z				; RET Z
	DJNZ	ACT1
	XOR	A
	DEC	A
	RET					; Error RET NZ


;  ----------------------------------------------  DEACTIVATE CRC CHECKING  ----------------
	
STOP_CRC_CHECK:					; Will now stop CRC checking
	CALL	DRIVE_CS_ON			; Lower CS on current SD card
	LD	HL,CMD_59
	CALL	SEND_SD_CMD			; SEND CMD59 Turn off CRC checking
	CALL	READ_RESULT			; Value returned in [A]
	CALL	SD_CS_OFF			; Turn off CS on both SD Cards
	CP	A,0H
	RET	Z				; RET Z
	XOR	A
	DEC	A
	RET					; Error RET NZ
	

;  ---------------------------------------------- SET SECTOR SIZE FOR TYPE 1 & 2 CARDS  ----------------

SET_SEC_SIZE:					; Will now set the sector size to 512 bytes
	CALL	DRIVE_CS_ON			; Lower CS on current SD card
	LD	HL,CMD_16
	CALL	SEND_SD_CMD			; SEND CMD16 to set sector size (512 Bytes)
	CALL	READ_RESULT			; Value returned in [A]
	CALL	SD_CS_OFF			; Turn off CS on both SD Cards
	CP	A,0H				; Should be 00000000B
	RET	Z				; RET Z
	XOR	A
	DEC	A
	RET					; Error RET NZ


;------------------------------------------------ SEND CARD STATUS --------------------------------------

GET_CARD_STATUS:				; Get card status		
	LD	B,40				; Try several times
CARD_STATUS_1:
	CALL	DRIVE_CS_ON			; Lower CS on current SD card
	LD	HL,CMD_13			; <<<<<<<< SEND CMD13 
	CALL	SEND_SD_CMD	
	CALL	READ_RESULT
	CALL	SD_CS_OFF			; -- Turn off CS on both SD Cards
	CP	A,0
	JP	Z,CARD_STATUS_2			
	DJNZ	CARD_STATUS_1			; Need to retry several times.
	XOR	A
	DEC	A
	RET					; Error RET NZ
CARD_STATUS_2:
	LD	A,0FFH				; Flush with extra 0FF's
	CALL	WRITE_SPI
	LD	A,0FFH				; Flush with extra 0FF's
	CALL	WRITE_SPI
	CALL	SD_CS_OFF			; -- Turn off CS on both SD Cards
	XOR	A
	RET					; Error RET Z

;==========================================  READ A SECTOR  =====================================================

READ_SECTOR:
	LD	HL,READ_SEC_MSG1		; '1,  Will read a sector from SD Card.',CR,LF,0H
	CALL	PMSG
	LD	A,(@CARD_TYPE)			; Flag to check if SD card type has been determined 
	OR	A,A
	JP	NZ,READ_SEC_OK
	LD	HL,READ_ERR_MSG1		; 'Sorry, SD Card must first be initilized (Menu 0).
	CALL	PMSG
	JP	START1				; Back to main menu

READ_SEC_OK:
	LD	HL,ENTER_SEC_NUM		; 'Please enter Sector Number (XXXXH):
	CALL	PMSG
	CALL	GET_HEX4
	JP	C,DATA_ERROR
	LD	(@SEC_ADDRESS),HL		; Store for later
	
	CALL	GET_SECTOR			; Read sector
	RET	NZ				; Abort if read failed

	LD	HL,SEC_RD_OK_MSG		; Sector Read OK
	CALL	PMSG
	LD	HL,(@SEC_ADDRESS)
	CALL	PRINT_HL			; Sector #
	LD	HL,SEC_RD1_OK_MSG		; 'H was read correctly.'
	CALL	PMSG

IF	DEBUG					;If required to display buffer contents
	JP	READ_BUFFER			; <--- CAN SKIP DISPLAYING BUFFER HERE
ENDIF
	RET

GET_SECTOR:
	; READ SECTOR @SEC_ADDRESS FROM @CURENT_DRIVE INTO @DMA BUFFER
IF SPI_SPEED
	CALL	HIGH_SPEED_CLK			; Run SPI at 10MHz
ELSE
	CALL	LOW_SPEED_CLK			; Run SPI at 40KHz
ENDIF
	; PREPARE THE SD CARD TO FOR A COMMAND
	CALL	DRIVE_CS_ON			; Lower CS on current SD card
	CALL	WAIT_SD_BUSY			; Wait for SD Card to be busy

	; SEND READ COMMAND
	LD	A,51H				; <<<<<<<< SEND CMD17  OR bits 40H added
	CALL	WRITE_SPI

	; SEND SECTOR NUMBER, ONLY 16 BITS OF LBA HANDLED HERE
	LD	A,0				; Second byte of CMD
	CALL	WRITE_SPI
	LD	A,0				; Third byte of CMD
	CALL	WRITE_SPI
	LD	HL,(@SEC_ADDRESS)											
	LD	A,H				; Forth byte of CMD 
	CALL	WRITE_SPI
	LD	A,L				; Fifth byte of CMD
	CALL	WRITE_SPI
	LD	A,0FFH				; CRC byte of CMD
	CALL	WRITE_SPI
	LD	A,0FFH				; Flush with extra 0FF's
	CALL	WRITE_SPI

	; GET COMMAND RESULT
	CALL	READ_RESULT
	OR	A				; Should be 00000000B
	JR	Z,GET_SEC_OK1
	LD	HL,SEC_RD_ERR0_MSG		; Got error with Read Sector command CMD17. (Status = "
	JP	CMD_FAIL			; Deselect CS, Low speed CLK, send error Message0

	LD	B,0H
GET_SEC_OK1:
	CALL	READ_SPI
	CP	A,0FFH
	JR	Z,GET_SEC_OK1
	CP	A,0FEH				; Should be 0FEH (Start Token)
	JP	Z,GET_SEC_OK2
	DJNZ	GET_SEC_OK1			; Keep trying until we see 0FEH
	LD	HL,SEC_RD_ERR1_MSG		; Got error with Read Sector command CMD17. (Status = "
	JP	CMD_FAIL			; Deselect CS, Low speed CLK, send error Message

GET_SEC_OK2:
	; READ THE SECTOR (2 CHUNKS OF 256 BYTES)
	LD	HL,(@DMA)
	LD	B,0
GET_256:
	CALL	READ_SPI
	LD	(HL),A
	INC	HL
	DJNZ	GET_256
	LD	B,0
GET_512:
	CALL	READ_SPI
	LD	(HL),A
	INC	HL
	DJNZ	GET_512

	; READ AND DISCARD CRC BYTES
	CALL	READ_SPI			; Read 16 bit CRC 
	CALL	READ_SPI
	
	; FLUSH
	CALL	READ_SPI			; Need one extra!

	; CLEAN UP
	CALL	SD_CS_OFF			; Turn off CS on both SD Cards
	CALL	LOW_SPEED_CLK
	XOR	A,A				; Signal success
	RET

;------------------------------------------------------------------------------------------------------

READ_BUFFER:					;  ROUTINE TO DISPLAY DMA/BUFFER  CONTENTS 
	LD	HL,RAM_DATA			; '512 Bytes of RAM buffer data. (Starting at RAM location '
	CALL	PMSG
	LD	HL,(@DMA)
	CALL	PRINT_HL
	LD	HL,BITS_END_MSG			; "'H)',CR,LF,0"
	CALL	PMSG
	
	LD	HL,(@DMA)			; Get pointer
	CALL	HEXDUMP				; Display buffer contents
	LD	HL,CONTINUE_MSG			; 'Type any character to continue.
	CALL	PMSG
	CALL	CI
	RET

	

;==========================================  WRITE A SECTOR  =====================================================

WRITE_SECTOR:
	LD	HL,WRITE_SEC_MSG1		; '3,  Will read a sector from SD Card.',CR,LF,0H
	CALL	PMSG
	LD	A,(@CARD_TYPE)			; Flag to check if SD card type has been determined
	OR	A,A
	JP	NZ,WRITE_SEC_OK
	LD	HL,READ_ERR_MSG1		; 'Sorry, SD Card must first be initilized (Menu 0).
	CALL	PMSG
	JP	START1				; Back to main menu

WRITE_SEC_OK:
	LD	HL,ENTER_SEC_NUM		; 'Please enter Sector Number (XXXXH):
	CALL	PMSG
	CALL	GET_HEX4
	JP	C,DATA_ERROR
	LD	(@SEC_ADDRESS),HL		; Store for later
	
	CALL	PUT_SECTOR
	RET	NZ
	
	LD	HL,SEC_WR_OK_MSG		; 'Sector'
	CALL	PMSG
	LD	HL,(@SEC_ADDRESS)
	CALL	PRINT_HL			; Sector #
	LD	HL,SEC_WR1_OK_MSG		; 'H was written correctly.'
	CALL	PMSG
	XOR	A,A
	RET
	

	
	
	
PUT_SECTOR:	
	; WRITE SECTOR @SEC_ADDRESS FROM @DMA BUFFER TO @CURENT_DRIVE
IF SPI_SPEED
	CALL	HIGH_SPEED_CLK			; Run SPI at 10MHz
ELSE
	CALL	LOW_SPEED_CLK			; Run SPI at 40KHz
ENDIF

	; PREPARE THE SD CARD TO FOR A COMMAND
	CALL	DRIVE_CS_ON			; Lower CS on current SD card
	CALL	WAIT_SD_BUSY

	; SEND WRITE COMMAND
	LD	A,58H				; <<<<<<<< SEND CMD24  OR bits 40H added
	CALL	WRITE_SPI

	; SEND SECTOR NUMBER, ONLY 16 BITS OF LBA HANDLED HERE
	LD	A,0				; Second byte of CMD
	CALL	WRITE_SPI
	LD	A,0				; Third byte of CMD
	CALL	WRITE_SPI
	LD	HL,(@SEC_ADDRESS)											
	LD	A,L				; Forth byte of CMD 
	CALL	WRITE_SPI
	LD	A,H				; Fifth byte of CMD
	CALL	WRITE_SPI
	LD	A,0FFH				; CRC byte of CMD
	CALL	WRITE_SPI
	LD	A,0FFH				; Flush with extra 0FF's
	CALL	WRITE_SPI

	; GET COMMAND RESULT
	CALL	READ_RESULT
	OR	A				; Should be 00000000B
	JR	Z,PUT_SEC_OK1
	LD	HL,SEC_WR_ERR0_MSG		; 'Got error with Write Sector command CMD24. (Status = 
	JP	CMD_FAIL			; Deselect CS, Low speed CLK, send error Message

PUT_SEC_OK1:
	LD	A,0FEH				; Start Block write flag
	CALL	WRITE_SPI

	LD	HL,(@DMA)
	LD	B,0
PUT_256:
	LD	A,(HL)
	CALL	WRITE_SPI
	INC	HL
	DJNZ	PUT_256
	LD	B,0
PUT_512:
	LD	A,(HL)
	CALL	WRITE_SPI
	INC	HL
	DJNZ	PUT_512

	LD	A,0FFH				; Send 16 bit CRC
	CALL	WRITE_SPI
	CALL	WRITE_SPI

	LD	HL,0				; Up to 64K times
PUT_END:
	CALL	READ_SPI			; Read a byte
	CP	0FFH				; Is it $FF
	JR	NZ,PUT_END1			; If not, move on
	DEC	HL				; Dec loop counter
	LD	A,L				; Check
	OR	A,H				; ... for timeout
	JR	NZ,PUT_END			; Loop as needed
	; If loop timeout, fall thru will diagnose

PUT_END1:
	AND	A,1FH
	CP	A,05H				; Should be xxx0AAA1H (AAA = 010)
	JR	Z,PUT_SEC_OK2
	LD	HL,SEC_WR_ERR1_MSG		; Got error with Read Sector command CMD24. (Status = "
	JP	CMD_FAIL			; Deselect CS, Low speed CLK, send error Message

PUT_SEC_OK2:
	; Clean up
	CALL	SD_CS_OFF			; Turn off CS on both SD Cards
	CALL	LOW_SPEED_CLK
	XOR	A,A				; Signal success
	RET

;==================================================================================================================

SET_DMA:	
	LD	HL,ENTER_RAM_LOC		; '4,  Set Sector RAM  Buffer.'
	CALL	PMSG
	LD	HL,ENTER_RAM_LOC1		; 'Please enter RAM buffer location (XXXXH): 
	CALL	PMSG
	CALL	GET_HEX4
	JP	C,DATA_ERROR
	LD	(@DMA),HL			; Store for later
	XOR	A,A
	RET
	
	
;========================================== LOAD ROMWBW ====================================================

CPM_BOOT:
	; Announce
	LD	DE,WBWLOAD$MSG
	CALL	PSTRING

	; Initialize SD Card
	LD	A,0				; Need to get card type
	LD	(@CARD_TYPE),A			; Flag to indicate SD card type has not yet been determined
	CALL	SEND_SD_RESET	
	JP	NZ,BOOT_READ_ERR1		; Error resetting SD Card before boot sector read, CMD0. (Status = 
	CALL	PRTDOT
	
	CALL	SEND_GET_TYPE
	JP	NZ,BOOT_READ_ERR2		; Error getting SD card Type before boot sector read, CMD8. (Status = '
	CALL	PRTDOT
	
	CALL	TYPE_2_ACTIVATE			; Initilize a Type 2 Card
	JP	NZ,BOOT_READ_ERR3		; Error activating SD Card Type 2 before boot sector read, CMD55+CMD41. (Status =
	CALL	PRTDOT

	; This is the main loading loop.  Each MMU bank is 16K, so we
	; have an inner loop to read and load 32 sectors.  An outer
	; loop increments the MMU bank selection, so we wind up loading
	; the desired 128K total.
	LD	HL,1024			; HL is LBA (start from sec 1024)
	LD	C,0			; C is MMU bank (start from 0)
BOOT1:
	; Show progress, display bank # being loaded
	CALL	PRTDOT
	;LD	DE,BANK$MSG
	;CALL	PSTRING
	LD	A,C
	;CALL	PHEX

	; Setup for inner loop
	LD	DE,0000H		; DE is RAM address
	LD	B,32			; B is sector count, load 32 sectors per bank
	LD	A,C			; get bank to be loaded
	OUT	(MPGSEL_0),A		; and select it
	OUT	(0FFH),A		; diagnostic LEDs

BOOT2:
	; Bank load loop
	LD	(@SEC_ADDRESS),HL	; setup next LBA to read
	PUSH	BC			; save loop control
	PUSH	HL			; save LBA
	LD	(@DMA),DE		; setup DMA for read
	CALL	GET_SECTOR		; HL will be incremented
	EX	DE,HL			; updated DMA value to DE
	POP	HL			; recover LBA
	POP	BC			; recover loop control
	RET	NZ			; abort on error
	;CALL	PRTDOT			; show progress
	INC	HL			; next sector
	DJNZ	BOOT2			; loop until all bank sectors done

	; Setup for next bank and check for done
	INC	C			; next bank
	LD	A,C			; put in A
	CP	8			; 128K / 16K = 8 banks
	JR	NZ,BOOT1		; loop until all banks done
	
	; Back to origin bank
	XOR	A
	OUT	(MPGSEL_0),A
	OUT	(0FFH),A		; diagnostic LEDs

	; Completion message
	LD	DE,WBWDONE$MSG
	CALL	PSTRING

	; Back to main menu (page 0)
	JP	ACTIVATE_LOW_PAGE

BOOT_READ_ERR1:	
	LD	HL,BOOT_ERR1_MSG		; Error resetting SD Card before boot sector read, CMD0. (Status = 
	JP	CMD_FAIL			; Deselect CS, Low speed CLK, send error Message
	
BOOT_READ_ERR2:	
	LD	HL,BOOT_ERR2_MSG		; Error getting SD card Type before boot sector read, CMD8. (Status = 
	JP	CMD_FAIL			; Deselect CS, Low speed CLK, send error Message

BOOT_READ_ERR3:	
	LD	HL,BOOT_ERR3_MSG		; Error activating SD Card Type 2 before boot sector read, CMD55+CMD41. (Status = 
	JP	CMD_FAIL			; Deselect CS, Low speed CLK, send error Message

PRTDOT:
	PUSH	AF
	LD	A,'.'
	CALL	PRTCHR
	POP	AF
	RET

PRTCHR:
	PUSH	BC
	LD	C,A
	CALL	CO
	POP	BC
	RET

PSTRING:
	PUSH	BC
	PUSH	DE
	PUSH	HL
	EX	DE,HL
PSTRX:	LD	A,(HL)
	CP	'$'
	JP	Z,DONEP
	LD	C,A
	CALL	CO
	INC	HL
	JP	PSTRX
DONEP:	POP	HL
	POP	DE
	POP	BC
	RET

PHEX:
	PUSH	AF
	PUSH	BC
	CALL	PRINT_A
	POP	BC
	POP	AF
	RET

;---------------------------------------------------------------------------------------------------------------------

GET_DRIVE:
	LD	HL,GET_DRIVE_MSG		; '6, Get Drive.'
	CALL	PMSG
GET_DRIVE1:
	LD	HL,GET_DRIVE_MSG1		; 'Please enter current drive (A/B) '
	CALL	PMSG
	CALL	CI
	CALL	UCASE				; Convert to upper case
	CP	A,ESC
	RET	Z
	LD	C,A
	PUSH	AF				; Save entry
	CALL	CO				; Echo it
	POP	AF				; Restore entry
	SUB	'A'				; convert to zero indexed
	JR	Z,SET_Z				; if 0, handle drive A
	CP	1				; drive b?
	JR	Z,SET_Z				; if so, handle it
	JR	GET_DRIVE1			; bad input, loop
SET_Z:	LD	(@CURRENT_DRIVE),A		; Set to drive B
	XOR	A,A
	LD	(@CARD_TYPE),A			; Reset card type to unknown
	CALL	CRLF
	RET
	
;------------------------- SPI COMMANDS -------------------------------------------------

SPI_DUMMY_CLOCK:			; Only [A] register altered
	PUSH	AF
	LD	A,0FFH
	CALL	WRITE_SPI
	POP	AF
	RET

WAIT_SD_BUSY:
	; WAIT FOR SD CARD TO BE READY FOR A COMMAND
	PUSH	AF
	PUSH	BC
SEND_SD_CMD1:
	CALL	READ_SPI
	INC	A			; FF --> 00
	JR	Z,SEND_SD_CMD2
	DJNZ	SEND_SD_CMD1
	; WHAT DO WE DO HERE???
SEND_SD_CMD2:
	POP	BC
	POP	AF
	RET

SEND_SD_CMD:				; Generalized CMD to send SD Card 6 commands. Only [A] & [HL] registers altered
	CALL	WAIT_SD_BUSY
SEND_SD_CMD_NOWAIT:
	LD	A,(HL)			; Get first byte from CMD table (Note already has OR bits 40H added)
	CALL	WRITE_SPI
	INC	HL
	LD	A,(HL)			; Get second byte from CMD table 
	CALL	WRITE_SPI
	INC	HL
	LD	A,(HL)			; Get third byte from CMD table 
	CALL	WRITE_SPI
	INC	HL
	LD	A,(HL)			; Get forth byte from CMD table 
	CALL	WRITE_SPI
	INC	HL
	LD	A,(HL)			; Get fifth byte from CMD table 
	CALL	WRITE_SPI
	INC	HL
	LD	A,(HL)			; Get sixth byte from CMD table 
	CALL	WRITE_SPI

	INC	HL
	LD	A,(HL)			; Send dummy byte to get returned message (Required!)
	CALL	WRITE_SPI
	RET

	
	
WRITE_SPI:				; Only [A] register altered
	PUSH	AF
WRITE1:	IN	A,(SD_STATUS)
	AND	A,80H
	JP	NZ,WRITE1
	POP	AF
	OUT	(SD_DATA_OUT),A
	OUT	(SD_RW),A
	CALL	SHORT_DELAY		; Seems to require time for busy signal to become valid
WRITE2:	IN	A,(SD_STATUS)
	AND	A,80H
	JP	NZ,WRITE2
	RET


READ_SPI:				; Only [A] register altered
	IN	A,(SD_STATUS)		; Wait until SD card is ready.
	AND	A,80H
	JP	NZ,READ_SPI
	IN	A,(SD_RW)		; Send Read pulse
	CALL	SHORT_DELAY		; Seems to require time for busy signal to become valid
READ1:	IN	A,(SD_STATUS)
	AND	A,80H
	JP	NZ,READ1
	IN	A,(SD_DATA_IN)		; Return data in [A]
	RET

READ_RESULT:
	PUSH	BC			; Save for caller
	LD	B,20			; Loop counter
READ_RESULT1:
	CALL	READ_SPI		; Get a byte from SPI
	BIT	7,A			; Check high bit
	JR	Z,READ_RESULT2		; If zero, we have result
	DJNZ	READ_RESULT1		; Keep trying till timeout
READ_RESULT2:
	POP	BC			; Restore for caller
	RET				; Return with latest byte read

CMD_FAIL:				; Generalized failure message routine (Message in [HL])
	CALL	SD_CS_OFF		; Always, turn off CS on both SD Cards
	CALL	LOW_SPEED_CLK
	CALL	PMSG
	IN	A,(SD_DATA_IN)		; Return data in [A] (Is latched in FPGA port)
	CALL	ZBITS
	LD	HL,BITS_END_MSG		; "B) "
	CALL	PMSG
	XOR	A
	DEC	A
	RET				; Return NZ

					
DRIVE_CS_ON:				; Lower CS on current SD card	
	PUSH	AF			; Note no registers altered
	LD	A,(@CURRENT_DRIVE)
	OR	A,A
	JP	NZ,DRIVE_B_CS
	LD	A,SD_CS_A		; Drive A select bit	
	OUT	(SD_CS_PORT),A
	POP	AF
	RET
DRIVE_B_CS
	LD	A,SD_CS_B		; Drive B select bit		
	OUT	(SD_CS_PORT),A
	POP	AF
	RET
					
SD_CS_OFF:				; Raise CS on both SD cards	
	PUSH	AF			; Note no registers altered
	
	; Spec requires 8 clocks before shutting down
	LD	A,0FFH
	CALL	WRITE_SPI

	; Deselect all cards
	LD	A,0FFH			
	OUT	(SD_CS_PORT),A

	POP	AF
	RET
	
HIGH_SPEED_CLK:				; Switch SPI Clock to 10MHz
	PUSH	AF
	LD	A,HIGH_SPEED
	OUT	(SD_SPEED_PORT),A
	POP	AF
	RET

LOW_SPEED_CLK:				; Switch SPI Clock to 40KHz
	PUSH	AF
	LD	A,LOW_SPEED
	OUT	(SD_SPEED_PORT),A
	POP	AF
	RET

SHORT_DELAY:				; Note no registers altered
	PUSH	BC
	LD	B,0FH
DELAY1:	DJNZ	DELAY1
	POP	BC
	RET

DELAY_5MS:
	; Delay 5ms assuming 8 MHz operation, so 40,000 TS
	; At 8 MHz, 1us is 8TS, 5ms = 5000us * 8TS = 40000
	PUSH	AF
	PUSH	HL
	LD	HL,+(40000/72)
DELAY_5MS1:
	EX	(SP),IX			; 23 TS
	EX	(SP),IX			; 23 TS
	DEC	HL			; 6 TS
	LD	A,H			; 4 TS
	OR	L			; 4 TS
	JR	NZ,DELAY_5MS1		; 12 TS		TOTAL=72
	POP	HL
	POP	AF
	RET


;<<<<<<<<<<<<<<<<<<<<<<<<< SUPPORT ROUTINES >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

PMSG:	PUSH	BC		; Only [A] and [HL] is changed
PMSG1:	LD	A,(HL)		; A ROUTINE TO PRINT OUT A STRING @ [HL]
	INC	HL		; UP TO THE FIRST 0.
	OR	A,A
	JP	Z,PMSG_DONE
	LD	C,A
	CALL	CO
	JP	PMSG1
PMSG_DONE:
	POP	BC
	RET

CRLF:	PUSH	AF
	PUSH	BC
	LD	C,CR
	CALL	CO
	LD	C,LF
	CALL	CO
	POP	BC
	POP	AF
	RET

BLANK:	PUSH	AF		; Send one space to console
	PUSH	BC
	LD	C,' '
	CALL	CO
	POP	BC
	POP	AF
	RET


; GET A CHARACTER, convert to UC, ECHO it
GETCMD:	CALL	CI		
	CALL	UCASE
	CP	A,ESC
	RET	Z		;Don't echo an ESC
	PUSH	AF		;Save it
	PUSH	BC
	LD	C,A
	CALL	CO		;Echo it
	POP	BC
	POP	AF		;get it back
	RET
;				;Convert LC to UC
UCASE:	CP	A,'a'		;must be >= lowercase a
	RET	C		; else go back...
	CP	A,'z'+1		;must be <= lowercase z
	RET	NC		; else go back...
	SUB	A,'a'-'A'	;subtract lowercase bias
	RET

; Check if next character is a ESC
CHECK_ESC:
	CALL	CI
	CP	A,ESC
	RET			; Return Z if ESC character.
	
; Check if next character is a CR
CHECK_CR:
	CALL	CI
	CP	A,CR
	RET			; Return Z if ESC character.
	
; Return with 2 HEX digits in [A]. If abort, Carry flag set + ESC in [A]
GET_HEX:
	PUSH	BC			
	CALL	GETCMD		;Get a character from keyboard & ECHO
	CP	A,ESC
	JP	Z,HEX_ABORT
	CP	'/'		;check 0-9, A-F
	JP	C,HEX_ABORT
	CP	'F'+1
	JP	NC,HEX_ABORT
	CALL	ASBIN		;Convert to binary
	SLA	A
	SLA	A
	SLA	A
	SLA	A		;Shift to high nibble	
	LD	B,A		;Store it
	CALL	GETCMD		;Get 2nd character from keyboard & ECHO
	CP	A,ESC
	JP	Z,HEX_ABORT
	CP	'/'		;check 0-9, A-F
	JP	C,HEX_ABORT
	CP	'F'+1
	JP	NC,HEX_ABORT
	CALL	ASBIN		;Convert to binary
	OR	A,B		;add in the first digit
	OR	A,A		;To return NC
	POP	BC
	RET
	
HEX_ABORT:
	SCF			;Set Carry flag 
	LD	A,ESC
	POP	BC
	RET
;
;
; Put 4 HEX characters in [HL] 
GET_HEX4:	
	LD      H,0000H
	CALL	GET_HEX		;get 2 HEX digits
	JP	C,SCAN_ABORT
	LD	H,A
	CALL	GET_HEX		;get 2 more HEX digits
	JP	C,SCAN_ABORT
	LD	L,A
	OR	A,A		;To return NC
	RET
	
SCAN_ABORT:
	SCF			;Set Carry flag 
	RET

; ASCII TO BINARY CONVERSION ROUTINE
ASBIN:	SUB	30H 
	CP	0AH 
	RET	M
	SUB	07H 
	RET
;	
;
; PRINT [HL] ON CONSOL
PRINT_HL:
	LD	A,H
	CALL	PRINT_A
	LD	A,L
PRINT_A:
	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	SF598B
	POP	AF
SF598B:	CALL	CONV
	JP	CO

; CONVERT HEX TO ASCII
CONV:	AND	0FH
	ADD	A,90H
	DAA 
	ADC	A,40H
	DAA 
	LD	C,A
	RET
	
; DISPLAY 8 BITS OF [A] (No registers changed)
; DISPLAY BIT PATTERN IN [A]
ZBITS:	PUSH	AF
	PUSH	BC
	PUSH	DE
	LD	E,A		
	LD	B,8
BQ2:	SLA	E	
	LD	A,18H
	ADC	A,A
	LD	C,A
	CALL	CO
	DJNZ	BQ2
	POP	DE
	POP	BC
	POP	AF
	RET

	
HEXDUMP:				;Print a hexdump of the data in the 512 byte buffer @[HL]
	LD	D,32			;Print 32 lines total
	LD	B,16			;16 characters across
	LD	(@StartLineHex),HL	;Save the buffer location for ASCII display below
	LD	HL,0
	LD	(@BYTE$COUNT),HL

SF172:	CALL	CRLF
	LD	HL,(@BYTE$COUNT)
	LD	A,H
	CALL	PRINT_A			;Print byte count in sector
	LD	A,L
	CALL	PRINT_A
	PUSH	DE
	LD	DE,16
	ADD	HL,DE
	POP	DE
	LD	(@BYTE$COUNT),HL	;store for next time
	CALL	BLANK
	LD	HL,(@StartLineHex)
	LD	(@StartLineASCII),HL	;Store for ASCII display below
SF175:	LD	A,(HL)
	CALL	PRINT_A			;Display [A] on CRT/LCD
	INC	HL
	DJNZ	SF175
	LD	(@StartLineHex),HL	;Save for next line later
	CALL	ShowAscii		;Now translate to ASCII and display
	LD	B,16			;16 characters across for next line
	DEC	D
	JP	NZ,SF172		;Have we done all 32 lines
	CALL	CRLF
	ret

ShowAscii:				;Now show as ascii info
	LD	HL,(@StartLineASCII)
	LD	B,16			;16 ASCII characters across
XF172:	CALL	BLANK			;send a space character
	CALL	BLANK
XF175:	LD	A,(hl)
	AND	7FH
	CP	' '			;FILTER OUT CONTROL CHARACTERS
	JP	NC,XT33
XT22:	LD	A,'.'
XT33:	CP	07CH
	JP	NC,XT22
	LD	C,A			;SET UP TO SEND
	push	bc
	CALL	CO
	pop	bc
	inc	hl			;Next position in buffer
	DJNZ	XF175
	ret




;<<<<<<<<<<<<<<<<<<<<<< MAIN CONSOL ROUTINES >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
;

CO:	IN	A,IOBYTE		;Find out where we send data
;	BIT	2,A	
;	JR	Z,VGA_CO		;To save space no VGA for now
	BIT	0,A	
	JR	Z,USB_CO		;USB port for output
	JR	PROP_CO			;For now everything else Propeller 	

PROP_CO:
	IN	A,(S100_CONSOL_STATUS)	;PROPELLER VIDIO BOARD PORT
	AND	4H
	JR	Z,PROP_CO		;Not yet ready, try both outputs
	LD	A,C
	CP	07H			;IS IT A BELL
	JP	Z,BELL1			;Special case
	CP	0H			;SD BOARD CANNOT TAKE A NULL!
	RET	Z
	OUT	(S100_CONSOL_OUT),A
	RET

BELL1:	LD	A,06H			;SEND A BELL
	OUT	(S100_CONSOL_OUT),A
	LD	A,0FH
	CALL	DELAY
	LD	A,07H
	OUT	(S100_CONSOL_OUT),A
	RET


DELAY:	DEC	A			;GENERAL COUNT DOWN TIME DELAY
	RET	Z			;LENGTH SET IN [A]
	PUSH	AF
	LD	A,05H
MORE:	DEC	A
	PUSH	AF
	XOR	A
MORE2:	DEC	A
	JR	NZ,MORE2
	POP	AF
	JR	NZ,MORE
	POP	AF
	JR	DELAY


USB_CO:	IN	A,(USB_STATUS_PORT)	;USB Port for Console OUT
	AND	00000010B
	JR	NZ,USB_CO		;Not yet ready - busy transmitting, try again
	LD	A,C
	AND	7FH			;Always 7 bits only.
	OUT	(USB_DATA_PORT),A
	RET


;<<<<<<<<<<<<<<<<<<< MAIN CONSOL STATUS ROUTINE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

CSTS:	IN	A,IOBYTE		;Find out where we get data
	BIT	1,A	
	JR	Z,PS2_CSTS
;	BIT	2,A			; To save space no VGA console for now
;	JR	Z,VGA_CSTS
	BIT	0,A	
	JR	Z,USB_CSTS		;USB port
	JR	PROP_CSTS		;For now everything else Propeller Console Board

PROP_CSTS:
	IN	A,(S100_CONSOL_STATUS)
	AND	02H
	JP	Z,NO_CSTS		;Zero if nothing
GOT_CSTS:
	XOR	A
	DEC	A			;RETURN WITH 0FFH IN [A] IF SOMETHING
	RET
NO_CSTS:
	XOR	A			
	RET				;RETURN WITH 0 IN A IF NOTHING THERE

USB_CSTS:
	IN	A,(USB_STATUS_PORT)
	AND	01H
	JR	Z,NO_CSTS		;Zero if nothing
	JR	GOT_CSTS

PS2_CSTS:
	IN	A,(PS2_STATUS_PORT)
	AND	01H
	JR	Z,NO_CSTS		;Zero/Low if nothing
	JR	GOT_CSTS

;<<<<<<<<<<<<<<<<<<<< MAIN CONSOL INPUT ROUTINE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

CI:	IN	A,IOBYTE		;Find out where we send data
	BIT	1,A	
	JR	Z,PS2_CI
;	BIT	2,A			; To save space no VGA Console for now
;	JR	Z,VGA_CI
	BIT	0,A	
	JR	Z,USB_CI		;USB port
	JR	PROP_CI			;For now everything else Propeller Console Board
	
PROP_CI:
	IN 	A,(S100_CONSOL_STATUS)	;NEED CONSTAT TO CLEAN UP SHIFT KEYS ETC
	AND	02H
	JR	Z,PROP_CI		;Wait until something there
	IN	A,(S100_CONSOL_IN)
	AND	7FH
	RET

USB_CI:
	IN 	A,(USB_STATUS_PORT)	;NEED CONSTAT TO CLEAN UP SHIFT KEYS ETC
	AND	01H
	JR	Z,USB_CI		;Wait until something there
	IN	A,(USB_DATA_PORT)
	AND	7FH			;Always 7 bits only.
	RET
	
PS2_CI:
	IN 	A,(PS2_STATUS_PORT)	;NEED CONSTAT TO CLEAN UP SHIFT KEYS ETC
	AND	01H
	JR	Z,PS2_CI		;Wait until something there
	IN	A,(PS2_DATA_PORT)
	AND	7FH			;Always 7 bits only.
	RET




;---------------------------------------------------------------------------------------
SIGNON:		DB	CR,LF
		DB	CR,LF,'SD CARD interface (V4.05)',0
		
SIGNON1:	DB	CR,LF,LF,'----- Main Menu ---- Buffer = ',0
SIGNON2:	DB	', Drive = ',0
SIGNON3:	DB	CR,LF
		DB	CR,LF,'0.   Initilize the SD CARD SPI Interface.'
		DB	CR,LF,'1.   Read a SD Sector.'
		DB	CR,LF,'2.   Display data in RAM sector buffer.'
		DB	CR,LF,'3.   Write 512 Bytes of RAM data to a Sector.'
		DB	CR,LF,'4.   Set sector RAM buffer location.'
		DB	CR,LF,'5.   Load RomWBW.'
		DB	CR,LF,'6.   Select Drive (A/B) '
		DB	CR,LF,'ESC  To abort program.',CR,LF,0H

DATA_ERROR_MSG:	DB	BELL,CR,LF,'Data entry error.',0
RESET_MSG:	DB	'0,  Initilize CF Card.',CR,LF,0H
RESET_OK_MSG:	DB	CR,LF,'SD_CARD was Reset OK',CR,LF,0
BITS_END_MSG:	DB	'B)',CR,LF,0
RESET_ERR_MSG:	DB	CR,LF,BELL,'SD_CARD was NOT Reset (Status = ',0
SD_TYPE_MSG:	DB	CR,LF,'Detected SD Card Type ',0
SD_TYPE_ERR_MSG: DB	CR,LF,BELL,'SD Card Type detection failed. (Status = ' ,0
SD_NOT_SUP_ERR:	DB	CR,LF,BELL,'SD Card Type not supported!',0
SIZE_OK_MSG:	DB	'Sector size = 512 bytes/sector.',CR,LF,0
READ_SEC_MSG1:	DB	'1,  Will read a sector.',CR,LF,0H
READ_ERR_MSG1:	DB	CR,LF,BELL,'SD Card must first be initilized (Menu 0).',CR,LF,0
CMD55_FAIL_MSG:	DB	CR,LF,BELL,'SD Card Type 2 Initilization failed (CMD55/CMD41) (Status = ',0
CMD41_55_OK_MSG: DB	'CMD55 & CMD41 Commands OK.',CR,LF
                DB	'The SD Card initilized correctly.',CR,LF,0
CRC_ERROR_MSG:	DB	CR,LF,BELL,'Error trying to turn off CRC checking. (Status = ',0
CRC_OFF_MSG:	DB	'Card CRC checking is now off.',CR,LF,0
SIZE_ERROR_MSG:	DB	CR,LF,BELL,'Sector size error. (Status = ',0	
SEC_RD_ERR0_MSG: DB	CR,LF,BELL,'Read Sector command CMD17 error. (Status = ',0
SEC_RD_ERR2_MSG: DB	CR,LF,BELL,'Read Sector command CMD17 error. Timed out (Status = ',0
SEC_RD_ERR1_MSG: DB	CR,LF,BELL,'Sector read error. No 0FEH Flag. (Status = ',0
ENTER_RAM_LOC:	DB	'4,  Set RAM buffer location.',CR,LF,0H
ENTER_RAM_LOC1:	DB	CR,LF,'Enter location (XXXXH): ',0
ENTER_SEC_NUM:	DB	CR,LF,'Enter Sector Number (XXXXH): ',0
SEC_RD_OK_MSG: DB	CR,LF,'Sector ',0
SEC_RD1_OK_MSG: DB	'H was read correctly.',0
RD_BUFFER_MSG:	DB	'2,  Will read a RAM data buffer',CR,LF,0H
RAM_DATA:	DB	CR,LF,LF,'RAM buffer data. (Starting at RAM location ',0
CONTINUE_MSG:	DB	CR,LF,'Type any character to continue.',0

WRITE_SEC_MSG1:	DB	'3,  Write a sector to SD Card.',CR,LF,0H
SEC_WR_ERR0_MSG: DB	CR,LF,BELL,'Sector write error, CMD24. (Status = ',0
SEC_WR_OK_MSG: DB	CR,LF,'Sector ',0
SEC_WR1_OK_MSG: DB	'H was written correctly.',CR,LF,0

SEC_WR_ERR1_MSG: DB	CR,LF,BELL,'Error writing Sector bytes, CMD24. (Status = ',0
SEC_WR_ERR2_MSG: DB	CR,LF,BELL,'Error waiting to complete sector write. (Status = ',0
SEC_WR_ERR3_MSG: DB	CR,LF,BELL,'Error resetting sector write, CMD0. (Status = ',0
SEC_WR_ERR4_MSG: DB	CR,LF,BELL,'Error getting Card type, CMD8. (Status = ',0
SEC_WR_ERR5_MSG: DB	CR,LF,BELL,'Error re-activating Type 2 Card, CMD55+CMD41. (Status = ',0

BOOT_ERR1_MSG:	DB	CR,LF,BELL,'Error resetting SD Card, CMD0. (Status = ',0
BOOT_ERR2_MSG: DB	CR,LF,BELL,'Error getting card Type, CMD8. (Status = ',0
BOOT_ERR3_MSG: DB	CR,LF,BELL,'Error activating Card, CMD55+CMD41. (Status = ',0
BOOT_ERR4_MSG: DB	CR,LF,BELL,'Error activating Card, CMD1. (Status = ',0

GET_DRIVE_MSG:	DB	'6, Get Drive.',CR,LF,0H
GET_DRIVE_MSG1:	DB	'Enter current drive (A/B) ',0

CMD_0:		DB	40H,00H,00H,00H,00H,95H,0FFH		; (0+64)  To Reset the SD Card interface,
CMD_1:		DB	41H,00H,00H,00H,00H,0F9H,0FFH		; (1+64)  Activate Init Process
CMD_8:		DB	48H,00H,00H,01H,0AAH,87H,0FFH		; (8+64)  To check Card Voltage
CMD_9:		DB	49H,00H,00H,00H,00H,8FH,0FFH		; (9+64)  Read SD Register (CSD)
CMD_13:		DB	4DH,00H,00H,00H,00H,081H,0FFH		; (13+64) get SD card status
CMD_16:		DB	50H,00H,00H,02H,00H,081H,0FFH		; (16+64) Set Sector size to 512 Bytes
CMD_17:		DB	51H,00H,00H,00H,00H,0FFH,0FFH		; (17+64) Read a single block (Block 0, Used to load boot sector only)
CMD_41:		DB	69H,40H,00H,00H,00H,077H,0FFH		; (41+64) Activates the card's init. process.
;CMD_41:	DB	69H,00H,00H,00H,000H,0E5H,0FFH		; (41+64) Activates the card's init. process.
CMD_55:		DB	77H,00H,00H,00H,00H,065H,0FFH		; (55+64) Application specific command NEXT
CMD_58:		DB	7AH,00H,00H,00H,00H,0FDH,0FFH		; (58+64) Read SD Cards OCR register
CMD_59:		DB	7BH,00H,00H,00H,00H,0FDH,0FFH		; (59+64) Turn off CRC checking

WBWLOAD$MSG	DB	CR,LF,'Loading RomWBW$'
WBWDONE$MSG	DB	CR,LF,'Done.  Use ''G0'' to launch.$'
BANK$MSG	DB	CR,LF,'Bank $'


; END
	



